<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 理解JVM内部原理[译] · kev's blog</title><meta name="description" content="理解JVM内部原理[译] - kevin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://kevll.com/atom.xml" title="kev's blog"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="kev's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/kitscode" target="_blank">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">理解JVM内部原理[译]</h1><div class="post-info">2018年4月8日</div><div class="post-content"><p>看到一篇说JVM的外文写的不错，自己翻译一下。<span id="more"></span><br>原文链接：<a target="_blank" rel="noopener" href="https://www.cubrid.org/blog/understanding-jvm-internals">https://www.cubrid.org/blog/understanding-jvm-internals</a><br>（文中图片均来自于原文）</p>
<p>每一个使用Java的开发者都知道Java字节码运行在JRE中（Java Runtime Environment）。JRE中最重要的元素就是Java虚拟机（JVM），由它解析和执行Java字节码。Java开发者不是必需要知道JVM是如何运行的。现在有许多开发出来的好的应用和库，而它们的开发者也没有对JVM有深入的理解。但是，如果你理解了JVM，你就会对Java有进一步的理解，也会有能力去解决那些看起来很简单却无法解决的问题了。<br>因此，在这篇文章中我将解释JVM是如何运行的，它的结构是怎样的，它怎样去执行Java字节码，执行的顺序，一些常见的错误和解决方法的案例，还有JavaSE7的新特性。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><blockquote>
<p>JRE是由Java API和JVM组成的。JVM通过类加载器来读取Java应用然后结合Java API来执行它。</p>
</blockquote>
<p>一个虚拟机（VM）是一个机器（也就是电脑）的软件层实现，这个机器可以像物理真机一样执行程序。起初的时候，Java是基于要运行在一个从物理机分离出来的虚拟机而设计的，为了实现WORA（一次编写处处运行），虽然这个目标已经差不多被遗忘了。因此，JVM可以在各种硬件上执行Java字节码而不用更改Java代码。</p>
<h2 id="JVM的特性如下所示："><a href="#JVM的特性如下所示：" class="headerlink" title="JVM的特性如下所示："></a>JVM的特性如下所示：</h2><ul>
<li><strong>基于栈的虚拟机</strong>：许多流行的计算机架构例如Intel x86架构和ARM架构都是基于寄存器的（register），然而JVM是基于栈的。</li>
<li><strong>符号引用</strong>：所有的类型（类和接口），除了原始数据类型外都是通过符号引用的，而不是通过显示的基于内存地址的引用。</li>
<li><strong>垃圾回收</strong>：一个类的实例由用户显示地创建出来然后自动地被垃圾回收销毁。</li>
<li><strong>清晰地定义了原始数据类型来保证平台独立性</strong>：传统的语言，例如C或C++，它们int类型的数据在不同的平台有不同的大小。JVM清晰地定义了原始数据类型来保证了它的兼容性和平台间的独立性。</li>
<li><strong>网络字节序</strong>：Java的class文件使用了基于网络的字节序。为了在使用小端(little endian)的x86结构和使用大端(big endian)的RISC系列结构中保持良好的平台间独立性，必须要保持一个固定的字节码顺序。因此，JVM使用了网络字节序用来做网络传输。网络字节序是大端。</li>
</ul>
<p>Sun公司开发了Java，但是任何供应商可以自行开发和提供一个基于JVM标准的JVM。因此市场上有很多不同的JVM，包括Oracle的Hotspot和IBM JVM。Google的Android系统中的Dalvik也是一种JVM，尽管它没有完全遵循JVM的实现标准。和Java这种基于栈的机器不同的是，Dalvik是基于寄存器的结构。Java字节码也会转换成由Dalvik虚拟机使用的基于寄存器的指令集。</p>
<h3 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h3><p>为了实现一次编写处处运行，JVM使用了字节码，一种处于编程语言和机器语言间的中间语言。Java字节码是部署Java代码的最小单位。在详细地解释Java字节码之前，我们先简单地看一下。下面是来自开发过程中发生的一个真实实例的总结。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一个曾经成功运行的程序运行不起来了，而且在库更新过后，返回了以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.nhn.user.UserAdmin.addUser(Ljava/lang/String;)V</span><br><span class="line">    at com.nhn.service.UserService.add(UserService.java:14)</span><br><span class="line">    at com.nhn.service.UserService.main(UserService.java:19)</span><br></pre></td></tr></table></figure>
<p>程序的代码如下所示，没有被改动过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// UserService.java</span><br><span class="line">…</span><br><span class="line">public void add(String userName) &#123;</span><br><span class="line">    admin.addUser(userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>升级前后的库源码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// UserAdmin.java - 更新后的代码</span><br><span class="line">…</span><br><span class="line">public User addUser(String userName) &#123;</span><br><span class="line">    User user = new User(userName);</span><br><span class="line">    User prevUser = userMap.put(userName, user);</span><br><span class="line">    return prevUser;</span><br><span class="line">&#125;</span><br><span class="line">// UserAdmin.java - 原始代码</span><br><span class="line">…</span><br><span class="line">public void addUser(String userName) &#123;</span><br><span class="line">    User user = new User(userName);</span><br><span class="line">    userMap.put(userName, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，没有返回值的addUser方法被改成了一个返回User类对象的方法。然而程序代码没有改变过，因为它并没有使用到addUser方法的返回值。</p>
<blockquote>
<p>第一眼看来，com.nhn.user.UserAdmin.addUser() 方法仍然存在，那为什么会发生NoSuchMethodError异常呢？</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>是因为程序代码没有被编译进新的库。换句话来说，程序代码看起来像是无视返回值调用了方法。但是，被编译过的类文件是明确知道这个方法的返回类型的。<br>你可以通过下列的错误信息看出这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.nhn.user.UserAdmin.addUser(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>
<p>NoSuchMethodError异常的发生是因为找不到”com.nhn.user.UserAdmin.addUser(Ljava&#x2F;lang&#x2F;String;)V”方法而引起的。注意看一下”Ljava&#x2F;lang&#x2F;String;”和最后的”V”。在Java字节码的表达中，”L<classname>;”表示类的实例。这表示addUser方法返回它需要一个java&#x2F;lang&#x2F;String类型的对象作为参数。在这个案例的库中，参数没有被改变，所以是正常的。异常信息最后一个”V”表示的就是方法的返回值。在Java字节码的表达中，”V”表示没有返回值。总结就是，异常信息表示一个需要java.lang.String为参数而返回值为com.nhn.user.UserAdmin.addUser的方法没有被找到。<br>因为程序代码被编译成之前库了，在这个类文件中定义的是要调用一个返回为”V”的方法。然而在改变过后的库中，返回”V”的方法已经不存在，而是加了一个返回”Lcom&#x2F;nhn&#x2F;user&#x2F;User;”的方法，所以发生了NoSuchMethodError的异常。</p>
<blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个错误的发生是因为开发者没有对更改后的代码进行重新编译。但是，在这个案例中，类库的提供者也要负大部分的责任。本来是一个公共的无返回值的方法，在之后被改成了返回User实例的方法。这明显是一个方法签名的更改。这意味着库的向后兼容已经被破坏了。所以，类库的的提供者必须要通知用户这个方法被改变了。</p>
</blockquote>
<p>让我们回到Java字节码，Java字节码是JVM的基本元素。JVM是一个执行Java字节码的执行器。Java编译器不会直接把一个高级语言，例如C&#x2F;C++，直接转换成机器语言（CPU指令）；它将开发者能够理解的Java代码转换成JVM能够理解的Java字节码。因为Java字节码是平台无关的，所以它在所有安装了JVM（准确来说是JRE环境）的硬件上都能被执行，即使当CPU或操作系统不同的时候也可以（一个在Windows上开发和编译过的类文件可以同样地在Linux的机器上运行，而且不用做任何的改变）。编译过后的文件大小基本与源代码的大小一致，使得通过网络来传输和执行Java字节码变得更简单。</p>
<p>class文件本身是一个二进制文件，人类不能直接进行阅读。为了管理class文件，JVM供应商提供了反编译器javap。使用javap得到的结果被称为Java编译指令。在上面的例子中，用javap -c option反编译程序代码中的UserService.add()方法得到的Java编译指令如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)V</span><br><span class="line">   8:   return</span><br></pre></td></tr></table></figure>
<p>在这个java编译指令中，addUser()方法在第四行被调用：”5:invokevirtual;”。这表示对应到23索引位置的方法应该被调用。23索引位置的方法也被javap程序打上了注释。”invokevirtual”是在Java字节码中调用方法的最基本的操作码(Opcode, operation code)。另外，Java字节码中有四种操作码可以调用方法，它们是：invokeinterface, invokespecial, invokestatic 和invokevirtual。每一种操作码的含义如下所示：</p>
<ul>
<li>invokeinterface：调用一个接口的方法</li>
<li>invokespecial：调用一个初始化方法、私有方法或者父类中的方法</li>
<li>invokestatic：调用一个静态方法</li>
<li>invokevirtual：调用一个实例方法</li>
</ul>
<p>Java字节码的指令集包括操作码和操作数。像invokevirtual这样的操作码需要2个字节的操作数。</p>
<p>通过在类库更新之后编译上面的程序代码然后反编译的话，得到的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return</span><br></pre></td></tr></table></figure>
<p>你可以看到对应到#23的方法已经改变为一个返回”Lcom&#x2F;nhn&#x2F;user&#x2F;User;”的方法了。</p>
<blockquote>
<p>在上面的反编译结果中，代码前面的数字是什么意思？</p>
</blockquote>
<p>它是字节数字。也许这就是为什么被JVM执行的代码要叫做“字节”码的原因。简单来说，这些字节码指令中的操作码，例如aload_0, getfield, 和invokevirtual都被表示为一个字节的字节数字。(aload_0&#x3D;0x2a, getfield&#x3D;0xb4, invokevirtual&#x3D;0xb6) 因此，Java字节码指令中最大的操作码数字为256。</p>
<p>像aload_0和aload_1这样的操作码不需要任何的操作数。因此aload_0的下一个字节就是下一个指令的操作码。然而像getfield和invokevirtual这样的操作码需要2个字节的操作数。因此，getfield的下一个指令的位置应该要跳过2个字节写在4字节的位置。通过16禁止编辑器查看到的字节码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a b4 00 0f 2b b6 00 17 57 b1</span><br></pre></td></tr></table></figure>

<p>在Java字节码中，类的实例被表示为“L;”，void被表示为“V”。类似的，其它的类型都有自己的表达方式。下面的表格总结了这些表示：<br>表1：Java字节码中的类型表示</p>
<table>
<thead>
<tr>
<th>Java字节码</th>
<th>类型</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>单字节</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode字符</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>整型</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>长整型</td>
</tr>
<tr>
<td>L<classname></td>
<td>引用</td>
<td>classname类型的实例</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>短整型</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>[</td>
<td>引用</td>
<td>一维数组</td>
</tr>
</tbody></table>
<p>下面的表格展示了一些字节码表示的例子：<br>表2：Java字节码表示的例子</p>
<table>
<thead>
<tr>
<th>Java代码</th>
<th>Java字节码表示</th>
</tr>
</thead>
<tbody><tr>
<td>double d[][][];</td>
<td>[[[D</td>
</tr>
<tr>
<td>Object mymethod(int i,double d,Thread t)</td>
<td>(IDLjava&#x2F;lang&#x2F;Thread;)Ljava&#x2F;lang&#x2F;Object;</td>
</tr>
</tbody></table>
<p>如果需要更多的细节，查看《Java虚拟机规范第二版》的4.3章描述符。在第6章可以查看各种Java字节码指令集的详细信息。</p>
<h2 id="类文件格式"><a href="#类文件格式" class="headerlink" title="类文件格式"></a>类文件格式</h2><p>在解释Java类文件格式之前，让我们来看一下一个在JavaWeb应用中经常发生的例子。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>编写了一个JSP然后在Tomcat上执行，JSP没有执行成功，发生了以下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet.service() for servlet jsp threw exception org.apache.jasper.JasperException: Unable to compile class for JSP Generated servlet error:</span><br><span class="line">The code of method _jspService(HttpServletRequest, HttpServletResponse) is exceeding the 65535 bytes limit&quot;</span><br></pre></td></tr></table></figure>
<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>以上的错误信息在不同的Web应用容器中可能有稍微的不同，但是，有一点是相同的，那就是因为65536字节的限制。65536字节限制是一种JVM的限制，规定了一个方法最多不能超过65535个字节。<br>我将介绍这个65535字节限制，并且详细说明为什么要设立这个限制。<br>Java字节码中，表示分支和跳转的指令为“goto”和“jsr”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto [branchbyte1] [branchbyte2]</span><br><span class="line">jsr [branchbyte1] [branchbyte2]</span><br></pre></td></tr></table></figure>
<p>这两个指令都需要接受2个字节的有符号分支偏移量作为操作数，以至于让它们最大可以扩展到第65535个索引位。然而为了支持更大的分支范围，Java字节码还准备了“goto_w”和“jsr_w”，它们可以接受4个字节的有符号分支偏移量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto_w [branchbyte1] [branchbyte2] [branchbyte3] [branchbyte4]</span><br><span class="line">jsr_w [branchbyte1] [branchbyte2] [branchbyte3] [branchbyte4]</span><br></pre></td></tr></table></figure>
<p>使用这两个操作码的话，分支的范围就可以超过65535了。因此，Java方法65535字节的限制就可以被克服了。但是，因为其它的各种的Java类文件格式的限制，Java方法的大小还是不能超过65535个字节。我将简单地解释一下类文件格式来看看其它的一些限制。<br>Java类文件的大致结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_info constant_pool[constant_pool_count-1];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[fields_count];</span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];&#125;</span><br></pre></td></tr></table></figure>
<p>上面的结构来自《Java虚拟机规范第二版》的第4.1章“类文件结构”。</p>
<p>之前反编译过的UserService.class文件，用16进制编辑器可以看到文件前16字节如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca fe ba be 00 00 00 32 00 28 07 00 02 01 00 1b</span><br></pre></td></tr></table></figure>
<p>通过这些值，我们来看一下类文件的格式。</p>
<ul>
<li><strong>魔数：</strong> 类文件的前4个字节是一个魔数。这是一个用来区分Java类文件的预定义值。就像上面16进制编辑器显示的那样，这个值总是OxCAFEBABE。简单来说，当一个文件的开头前4个字节是0xCAFEBABE，这个文件就可以被看作一个Java类文件。”CAFEBABE”是一个有关”Java”这个名字的有趣的魔数。</li>
<li><strong>小版本，大版本：</strong> 接下来的4个字节表明了类的版本号。在UserService的类文件中的数值为0x00000032，类的版本号就是50.0。由JDK1.6编译的类文件的版本就是50.0，由JDK1.5编译的类文件的版本号就是49.0。JVM必须保持对比自己版本小的类文件的向后兼容性。另一方面来说，如果在一个低版本的JVM上执行高版本的类文件，就会发生java.lang.UnsupportedClassVersionError异常。</li>
<li><strong>常量池数，常量池：</strong> 在版本号之后就是类的常量池信息。这是在运行时常量池区域中的信息，将在之后解释。在加载类文件的时候，JVM把常量池的信息加载到了方法区中的运行常量池中。在UserService的类文件中constant_pool_count的值为0x0028，你可以看到常量池的索引有40-1&#x3D;39个。</li>
<li><strong>访问标识：</strong>:这是表示一个类的修饰符的符号位。它可以表示该类是否被public、final、abstract修饰，以及是否是一个interface。</li>
<li><strong>当前类，父类：</strong> 分别表示在常量池中的关于本类和父类的索引。</li>
<li><strong>接口数，接口：</strong> 表示了在常量池中的本类实现的接口数的索引，和每个接口的信息。</li>
<li><strong>变量数，变量：</strong> 类中变量的数量和变量的信息数组。变量的信息包括变量名、类型、修饰符，以及在常量池中的索引。</li>
<li><strong>方法数，方法：</strong> 一个类中的方法的数量和方法的信息数组。方法的信息包括了方法名、类型，和方法参数的数量、返回类型、修饰符，在常量池中的索引值，方法的可执行代码以及异常信息。</li>
<li><strong>属性数，属性：</strong> attribute_info有多种不同的属性。对于field_info或method_info，attribute_info就被使用了。</li>
</ul>
<p>javap反编译程序可简单地以一种用户可以读懂的方式展现出类文件的格式信息。当UserService.class使用“javap -verbose”解析过后，就展现以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;UserService.java&quot;</span><br><span class="line"> </span><br><span class="line">public class com.nhn.service.UserService extends java.lang.Object</span><br><span class="line">  SourceFile: &quot;UserService.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 50</span><br><span class="line">  Constant pool:const #1 = class        #2;     //  com/nhn/service/UserService</span><br><span class="line">const #2 = Asciz        com/nhn/service/UserService;</span><br><span class="line">const #3 = class        #4;     //  java/lang/Object</span><br><span class="line">const #4 = Asciz        java/lang/Object;</span><br><span class="line">const #5 = Asciz        admin;</span><br><span class="line">const #6 = Asciz        Lcom/nhn/user/UserAdmin;;// … omitted - constant pool continued …</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">// … omitted - method information …</span><br><span class="line"> </span><br><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   Stack=2, Locals=2, Args_size=2</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return  LineNumberTable:</span><br><span class="line">   line 14: 0</span><br><span class="line">   line 15: 9  LocalVariableTable:</span><br><span class="line">   Start  Length  Slot  Name   Signature</span><br><span class="line">   0      10      0    this       Lcom/nhn/service/UserService;</span><br><span class="line">   0      10      1    userName       Ljava/lang/String; // … Omitted - Other method information …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于篇幅限制，我从整体内容中提取了一部分。在全部的内容里还包括了其它各种关于常量池和每个方法的信息。<br>方法的65535字节大小限制与method_info的结构内容有关。method_info结构含有代码（Code），行号表（LineNumberTable），和本地变量表（LocalVariableTable）的属性，就像上面由“javap -verbose”命令展示出的一样。所有对应于行号表、本地变量表和代码中的异常表（exception_table）的长度的值都是固定的2个字节。因此，方法的长度不能超过行号表、本地变量表和异常表的长度，就被限制在了65535个字节。</p>
<p>许多的人抱怨方法大小的限制，JVM规范也声称将会在之后进行可扩充化，但是到目前为止还没有明确的进展。考虑到JVM规范的特性要将类文件中几乎所有的内容都加载到方法区，所以在扩展方法的大小同时要保证向后兼容性将是非常困难的。</p>
<blockquote>
<p>如果因为Java编译器的错误产生了一个错误的类文件会导致什么结果？或者，如果因为网络传输或者拷贝文件将一个类文件破坏了之后又会发生什么？</p>
</blockquote>
<p>为了应对这些情况，Java类加载器有一个非常严格的认证过程。JVM规范详细地描述了这个过程：</p>
<blockquote>
<p>注意</br><br>我们要如何证明JVM成功地执行了类文件认证的过程？我们如何证明不同的JVM厂商提供的不同的JVM平台是否满足了JVM规范？为此，Oracle提供了一个测试工具，TCK（Technology Compatibility Kit）。TCK通过执行数万个测试用例，包括在许多不同方式下产生错误类文件，来检验JVM的规范情况。通过了TCK的测试后，这个JVM才能被称为一个JVM。</p>
</blockquote>
<h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p>使用Java所写的代码是由下图所示的流程执行的：<br><img src="/180408_execution_process.png" alt="图1：Java代码执行流程"><br>Java类加载器将编译过后的Java字节码文件加载到运行时数据区域中，执行引擎执行Java字节码。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了动态加载的特性，它将在运行时类第一次被引用时才去加载和链接这个类，而不是在编译期间加载。JVM的类加载器完成这个动态加载的过程。Java类加载器的特性如下所示：</p>
<ul>
<li><strong>层次结构：</strong>Java中的类加载器被组织为一种父子关系的层次型结构，Bootstrap类加载器是所有类加载器的父类。</li>
<li><strong>委派模式：</strong>基于层次结构，加载任务将在类加载器之间进行委派。当一个类被加载后，将由父类检查和确认是否这个类已经被父加载器加载过。如果父类加载器中有这个类，那么就使用这个类。如果没有，就用当前类加载器来加载这个类。</li>
<li><strong>可见限制：</strong>子类加载器可以从父类加载器中获取类，然而，父类加载器不能从子类加载器中获取类。</li>
<li><strong>卸载禁止：</strong>一个类加载器可以加载一个类但不能卸载它。然而可以删除当前的类加载器，创建一个新的类加载器。</li>
</ul>
<p>每一个类加载器都有它自己保存的已加载类的命名空间。当一个类加载器加载一个类时，它将基于FQCN（Fully Qualified Class Name, 全限定名）来在命名空间中检查这个类是否已经被加载。即使类之间有相同的全限定名但是命名空间不同，也将被认为是不同的类。不同的命名空间表示这个类被其它的类加载器加载过。<br>下面的图说明了类加载器的委派模式：<br><img src="/180408_delegation_model.png" alt="图2：类加载器的委派模式"><br>当一个类加载器被用来加载类的时候，它将按照从加载器缓存，父类加载器，和它自己的顺序中检查这个类是否已经存在。简单来说，加载器先从缓存中检查这个类是否已经被加载。如果没有加载，检查父类加载器有没有加载，如果检查到Bootstrap类加载器还是不存在这个类的话，那么当前的类加载器将在文件系统中寻找这个类并加载它。</p>
<ul>
<li><strong>Bootstrap类加载器：</strong>当JVM启动时，这个类加载器就会被创建。它将加载Java APIs，包括object类。和其它的类加载器不同的是，它是由本地（native）代码实现的，而不是Java。</li>
<li><strong>扩展类加载器：</strong>它将加载除了基本的Java APIs以外的扩展类，也会加载各种安全扩展功能。</li>
<li><strong>系统类加载器：</strong>如果说Bootstrap类加载器和扩展加载器是加载JVM组件的，那系统类加载器就是加载应用类。它将加载用户指定的$CLASSPATH里的类。</li>
<li><strong>用户自定义类加载器：</strong>这是一个用户在代码中直接创建的类加载器。</li>
</ul>
<p>像Web应用服务器（WAS:Web application server）这样的框架使用这样的自定义类加载器，使得Web应用与企业级应用可以相互独立运行。换句话说，通过类加载器的委派模式可以保证应用之间的独立性。这样的WAS类加载器结构都使用了层次结构，然而不同供应商提供的相应结构可能稍有不同。</p>
<p>如果类加载器发现了一个未加载的类，类将由如下所示的过程被装载和链接：<br><img src="/180408_class_load.png" alt="图3：类加载步骤"><br>每一个步骤描述如下：</p>
<ul>
<li><strong>加载：</strong>从文件中获取类加载到JVM内存中</li>
<li><strong>认证：</strong>验证加载的类是否符合Java语言和JVM的规范。这是类加载过程中最复杂、耗时最长的的一个测试步骤。JVM的TCK测试的大部分要在这测试在加载错误的类时能否得到相应的错误信息。</li>
<li><strong>准备：</strong>准备好数据结构，它指定了类所需要的内存空间，并且表明了类中的域、方法和接口。</li>
<li><strong>解析：</strong>将常量池中所有的对当前类的符号引用改为直接引用。</li>
<li><strong>初始化：</strong>将类的变量初始化为一个合理的值，执行静态初始化方法，初始化静态域的相应值。</li>
</ul>
<p>JVM规范定义了这些任务，但是也允许在执行的时候灵活处理。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/180408_runtime_data_areas.png" alt="图4：运行时数据区域配置"><br>运行时数据区域是JVM在系统上运行的时候被划分出的内存空间。运行时的数据区域可以划分成6个部分。它们是：为每个线程独立创建的PC寄存器、虚拟机栈和本地方法栈，以及所有线程间共享的堆、方法区和运行时常量池。</p>
<ul>
<li><p><strong>PC寄存器：</strong>每一个线程拥有一个PC（Program Counter）寄存器，当线程启动时被创建。PC寄存器存有当前将被执行的JVM指令的地址。</p>
</li>
<li><p><strong>虚拟机栈：</strong>每一个线程拥有一个虚拟机栈，也是当线程启动时被创建。这是一个保存了栈帧（Stack Frame）的栈结构。JVM会将栈帧压入或弹出虚拟机栈。如果发生了异常，类似printStackTrace()这样的方法，输出的栈追踪的每行信息就是一个栈帧信息。<br><img src="/180408_jvm_stack.png" alt="图5：虚拟机栈配置"></p>
</li>
<li><p>栈帧：当JVM中的一个方法被执行后，就会创建一个栈帧，这个栈帧将被加到当前线程的虚拟机栈中。当方法结束时，相应的栈帧也会被移除。每一个栈帧保存了到本地变量数组、操作数栈，和被执行方法所属类的运行时常量池的引用。本地变量数组和操作数栈的大小都在编译期被确定了。因此，一个方法相应的栈帧大小也是固定的。</p>
</li>
<li><p>本地变量数组：数组的索引由0开始。0位置存储着方法所属类的实例的引用。从1开始保存的是传递给方法的参数。在方法参数后面保存的就是方法的本地变量了。</p>
</li>
<li><p>操作数栈：是一个方法真正意义上的工作空间。每个方法交换操作数栈和本地变量数组中的数据，压入或弹出调用其它方法的结果值。操作数栈所必须的空间大小可以在编译的时候确定，因此，操作数栈的大小也可以在编译时确定。</p>
</li>
<li><p><strong>本地方法栈：</strong>一个本地的非Java的代码栈。换句话说，这是一个通过JNI(Javs Native Interface)来执行C&#x2F;C++代码的栈。根据语言的不同，将会创建一个C栈或C++栈。</p>
</li>
<li><p><strong>方法区：</strong>这是一个被所有线程共享的方法区，当JVM启动的时候被创建。它储存了运行时常量池、域和方法信息，静态变量，还有每个被JVM加载的类和接口的方法字节码。不同的JVM厂商实现方法区的格式都有不同。Oracle的Hotspot虚拟机称之为永久区（Permanent Area）或是永久代（Permanent Generation, PermGen）。垃圾收集是否对于方法区进行收集是可由JVM厂商选择的。</p>
</li>
<li><p><strong>运行时常量池：</strong>一个与类文件格式中的常量池表相对应的区域。这个区域被包含在方法区中，但是它在JVM的操作中扮演着重要的角色。因此，JVM规范还单独地描述它的重要性。除了每个类和接口的常量，它还包含了所有对方法和域的引用。简单来说，当一个方法或域被引用时，JVM将使用运行时常量池去查找方法或域在内存中的实际地址。</p>
</li>
<li><p><strong>堆：</strong>一个存放了实例或对象的空间，也是垃圾收集的目标区域。当讨论JVM性能的时候这个区域经常被提及。JVM厂商可以决定如何配置堆或是不执行垃圾收集。</p>
</li>
</ul>
<p>让我们回到我们之前讨论的反编译字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return</span><br></pre></td></tr></table></figure>
<p>将反编译的代码与我们有时看见的x86架构的机器码进行比较，它们都有相似的格式，操作码，但是也有不同的地方：Java字节码不会写出寄存器的名称，内存地址或操作数的偏移位置。如之前描述的一样，JVM使用栈结构。因此，它不使用寄存器，与之不同的x86架构是使用寄存器的。它使用像15、23这样的索引而不是内存地址，是因为它自己管理内存。15、23这样的索引就是当前类（这里是UserService类）的常量池索引。简单来说，JVM为每一个类创建一个常量池，池中存放了对真实对象的引用。</p>
<p>反编译代码的每行解释如下：</p>
<ul>
<li>**aload_0:**将局部变量数组0索引处的元素加入操作数栈。局部变量表0索引处的元素总是this，代表了当前类的实例的引用。</li>
<li>**getfield #15:**在当前类的类常量池中，把索引为15的元素加入操作数栈。因为admin域是一个类实例，所以这里加入了一个引用。</li>
<li>**aload_1:**将局部变量数组1索引处的元素加入操作数栈。从局部变量表1索引开始存储的是方法的参数，所以当调用add()方法要传递的userName字符串的引用被加入到操作数栈。</li>
<li>**invokevirtual:**调用当前类常量池中#23处的方法。这时，使用getfield加入的引用和使用aload_1加入的参数被传递到调用的方法里。当方法调用结束后，返回值将被添加到操作数栈中。</li>
<li>**pop:**把调用invokevirtual方法的返回值从操作数栈弹出。你可以看到用之前的库编译的代码没有返回值。简单来说，之前的方法没有返回值，所以没有必要从栈中弹出返回值。</li>
<li>**return:**方法完成。</li>
</ul>
<p>下面的图将帮你理解上面的解析：<br><img src="/180408_bytecode_loaded.png" alt="图6：运行时数据区域加载Java字节码的例子"></p>
<p>为了示例，在这个方法中，本地变量数组没有被改变过。所以上图只展现了操作数栈的变化。但是，在大多的情况下，本地变量数组也会被改变。本地变量数组和操作数栈之间使用许多的加载指令（aload，iload）和存储指令（astore，istore）完成数据的传输。<br>在这个图中，我们看了一下运行时常量池和虚拟机栈的简短描述。当JVM启动时，每个类的实例将被分配到堆中，包含User，UserAdmin，UserService和String的类信息被存储到方法区中。</p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>通过类加载器被分配到JVM的运行时数据区域的字节码是通过执行引擎执行的。执行引擎以指令单元读入Java字节码。它就像CPU执行机器码一样一行一行依次执行。每一个字节码指令是由1个字节的操作码和附加的操作数组成的。执行引擎拿到一个操作码然后同操作数一起执行指令，然后执行下一个执行码。<br>但是Java字节码写成了人类可以理解的语言，而不是机器可以直接执行的语言。因此，执行引擎必须在JVM中将字节码转换为可以在机器上执行的语言指令。字节码有2种方式可以转换为合适的语言。</p>
<ul>
<li>解释器：读取，解释并逐行执行字节码指令。在它一行行地解释和执行指令地时候，它可以迅速解释一个字节码，但是解释结果的执行速度较慢。解释性语言都有这样的短处。字节码这样的语言基本上就像这样一个解释器一样运行。</li>
<li>即时编译器（JIT）：为了弥补解释器的这种短处，引入了JIT编译器。执行引擎先像一个解释器一样运行，然后在一个适当的时间，JIT编译器将整个字节码编译为本地代码。在那之后，执行引擎就不要再解释方法了，而是直接执行本地代码。本地代码的执行比一行行地解释指令要快得多。编译过的代码可以更快的执行，因为本地代码被储存在了缓存中。</li>
</ul>
<p>但是，JIT编译器编译代码比一行行地解释代码花费的时间要更多。因此，如果代码只被执行一次，那么解释比编译更好。因此，JVM在内部检查了方法被执行的频率，然后只在这个频率超过一个特定的水平的时候才进行即时编译。<br><img src="/180408_compiler_jit.png" alt="图7：Java编译器和即时编译器"></p>
<p>JVM规范并没有定义执行引擎如何运行。因此，虚拟机供应商使用各种不同的技术去提升他们的执行引擎，引入了各式不同的即时编译器。<br>大部分的即时编译器像下图一样运行：<br><img src="/180408_jit.png" alt="图8：即时编译器"></p>
<p>即时编译器将字节码转换成一种中间级的表达式，IR(Intermediate Representation)，优化之后，将这种表达式转换为本地代码。<br>Oracle Hotspot VM使用的是一种称为Hotspot编译器的即时编译器。它被称为Hotspot是因为Hotspot编译器搜索那些需要高优先级编译的“热点”代码，然后将这些“热点”编译为本地代码。如果一个方法含有编译过的字节码但是不再经常调用时，换句话来说就是这个方法不再是一个“热点”代码，Hotspot VM将移除缓存中的本地代码然后切换成解释器模式运行。Hotspot VM被分成Server VM和Client VM两种，这两种虚拟机使用不同的即时编译器。<br><img src="/180408_hotspot_client_server.png" alt="图9：Hotspot Client VM和Server VM"></p>
<p>Client VM和Server VM使用相同的运行时环境，但是他们使用不同的即时编译器，就像上图所示那样。Server VM使用的高级动态优化编译器使用了更为复杂和性能多样的优化技术。<br>IBM JVM从IBM JDK6引入了类似JIT编译器的AOT(Ahead Of Time)编译器。这意味着多个虚拟机之间可以通过共享缓存共享编译过后的本地代码。简单来说，已经通过AOT编译器编译过的代码可以被其它的JVM直接使用，不用再编译。另外，IBM JVM提供了一种快速执行代码的方法，通过使用AOT编译器将代码预编译成JXE(Java Executable)文件格式。</p>
<p>大部分的Java性能提升都是通过提升执行引擎实现的。像JIT编译器一样，各种优化技术被引入所以JVM的性能持续地提升。最初地JVM和最新地JVM之间的区别就是执行引擎的不同。</p>
<p>Hotspot编译器从Oracle Hotspot VM的1.3版本引入，JIT编译器从Android2.2开始引入Dalvik VM。</p>
<blockquote>
<p>注意<br>引入像字节码这样的中间语言的技术，用VM执行字节码，JIT编译器提升JVM的性能，在其它拥有中间语言的语言中这种方式也很常见。像Microsoft的.Net，他们的一种虚拟机称为CLR(Common Language Runtime)，执行一种称作CIL(Common Intermediate Language)的字节码。CLR提供像JIT编译器一样的AOT编译器。因此，用C#或VB.NET写的代码，经由编译器编译成CIL然后运行在有JIT编译器的CLR上。CLR也采用了垃圾处理机制，像JVM一样是基于栈的机器。</p>
</blockquote>
<h2 id="Java虚拟机规范，JavaSE第7版"><a href="#Java虚拟机规范，JavaSE第7版" class="headerlink" title="Java虚拟机规范，JavaSE第7版"></a>Java虚拟机规范，JavaSE第7版</h2><p>在2011年7月28号，Oracle发布了JavaSE第7版并将JVM规范也更新到了第7版。在1999年发布了《Java虚拟机规范第二版》后，Oracle花了12年才发布了更新版本。更新版本包含了许12年间积累的许多改变和修改，描述了一个更为清晰的规范文件。另外，它也描述了和JavaSE第7版一同发布的《Java虚拟机规范JavaSE第7版》里的一些内容，主要的改变可以总结如下：</p>
<ul>
<li>从JavaSE第5版引入泛型，支持可变参数的方法</li>
<li>从JavaSE第6版后字节码验证过程发生了改变</li>
<li>添加了invokedynamic指令和为了支持动态类型语言的相关类文件格式</li>
<li>删除了Java语言本身概念的描述，让读者到Java语言规范去查看这部分内容。</li>
<li>删除了有关Java线程和锁的描述，将这些内容放在了Java语言规范中。</li>
</ul>
<p>这些当中最大的改变就是invokedynamic指令的添加。这意味着JVM内部的指令集发生了改变，JVM开始支持类型可以不确定的动态类型语言，就像一个脚本语言一样，也是JavaSE第7版后的Java语言。之前未被使用的编号186的操作码被分配给了新的指令：invokedynamic，为了支持invokedynamic新的内容也被添加到了类文件格式中。<br>由JavaSE第7版的Java编译器产生的类文件的版本是51.0，JavaSE第6版是50.0。类文件格式中的许多内容被改变了，因此51.0版本的类文件不能在JavaSE第6版的JVM上执行。</p>
<p>除去这些各式各样的改变，65536字节的Java方法大小的限制依然没有被移除。除非JVM类文件格式有创新式的改变，否则在未来也不会被移除。</p>
<p>以备参考，Oracle的Java第7版虚拟机支持G1这种新的垃圾收集器。但是仅限于Oracle的虚拟机，所以JVM本身不会限制垃圾收集器的类型。因此JVM规范就没有描述这些内容了。</p>
<h2 id="switch语法中的String类型"><a href="#switch语法中的String类型" class="headerlink" title="switch语法中的String类型"></a>switch语法中的String类型</h2><p>JavaSE第7版添加了各种新的语法与特性，但是与JavaSE第7版语言诸多的改变相比，JVM却没有太大的改变。所以，JavaSE第7版的新特性要如何被实现？我们将通过反编译来看看switch语句中的String类型是如何实现支持的。（一个向switch语句添加一个字符串来作对比的功能）<br>例如，有以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SwitchTest</span><br><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public int doSwitch(String str) &#123;</span><br><span class="line">        switch (str) &#123;</span><br><span class="line">        case &quot;abc&quot;:        return 1;</span><br><span class="line">        case &quot;123&quot;:        return 2;</span><br><span class="line">        default:         return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然这是JavaSE第7版的新功能，它就可以被JavaSE第6版或是更低版本的编译器编译。使用JavaSE第7版的javac命令编译，以下就是javap -c反编译的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">C:Test&gt;javap -c SwitchTest.classCompiled from &quot;SwitchTest.java&quot;</span><br><span class="line">public class SwitchTest &#123;</span><br><span class="line">  public SwitchTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return  public int doSwitch(java.lang.String);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_1</span><br><span class="line">       1: astore_2</span><br><span class="line">       2: iconst_m1</span><br><span class="line">       3: istore_3</span><br><span class="line">       4: aload_2</span><br><span class="line">       5: invokevirtual #2                  // Method java/lang/String.hashCode:()I</span><br><span class="line">       8: lookupswitch  &#123; // 2</span><br><span class="line">                 48690: 50</span><br><span class="line">                 96354: 36</span><br><span class="line">               default: 61</span><br><span class="line">          &#125;</span><br><span class="line">      36: aload_2</span><br><span class="line">      37: ldc           #3                  // String abc</span><br><span class="line">      39: invokevirtual #4                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      42: ifeq          61</span><br><span class="line">      45: iconst_0</span><br><span class="line">      46: istore_3</span><br><span class="line">      47: goto          61</span><br><span class="line">      50: aload_2</span><br><span class="line">      51: ldc           #5                  // String 123</span><br><span class="line">      53: invokevirtual #4                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      56: ifeq          61</span><br><span class="line">      59: iconst_1</span><br><span class="line">      60: istore_3</span><br><span class="line">      61: iload_3</span><br><span class="line">      62: lookupswitch  &#123; // 2</span><br><span class="line">                     0: 88</span><br><span class="line">                     1: 90</span><br><span class="line">               default: 92</span><br><span class="line">          &#125;</span><br><span class="line">      88: iconst_1</span><br><span class="line">      89: ireturn</span><br><span class="line">      90: iconst_2</span><br><span class="line">      91: ireturn</span><br><span class="line">      92: iconst_0</span><br><span class="line">      93: ireturn</span><br></pre></td></tr></table></figure>
<p>一个明显比Java源码更长的字节码产生了。首先，你可以在Java字节码中看到switch语句使用了一个lookupswitch指令。但是，有2个lookupswitch指令被使用了，而不是一个。当反编译switch语句中的加了int的case时，只会调用一条lookupswitch指令，这意味着switch()语句被分成两个语句块去处理String。观察#5，#39和#53处的字节码指令来了解switch()是如何处理String的。<br>在#5和#8处的字节码首先调用了hashCode()方法，它的结果被switch(int)使用了。在lookupswitch指令的大括号中，根据hashCode结果值的不同创建了不同位置的分支。字符串“abc”的hashCode结果值为96354，被移到了#36字节码处。字符串“123”的hashCode结果值是48690，被移到了#50字节码处。</p>
<p>在#36，#37，#39和#42字节码处，你可以看到str变量值被当作参数接收并使用字符串“abc”和equals()方法与之比较。如果结果相同，‘0’将被插入本地变量数组#3索引处，string被移到#61字节码处。</p>
<p>这样，在#50，#51，#53和#56处的字节码，你可以看到str变量值被当作参数接收并使用字符串“123”和equals()方法与之比较。如果结果相同，‘1’将被插入本地变量数组#3索引处，string被移到#61字节码处。</p>
<p>在#61和#62字节码处，本地变量数组#3索引处的值，也就是‘0’，‘1’，或其它的任何值，将被lookupswitch使用并创建分支。</p>
<p>换句话说，在Java代码中，str变量值被当作参数接收并使用hashCode和equals()方法与之比较。有了int结果值后，执行switch()语句。</p>
<p>在这个案例中，编译后的字节码与之前JVM的规范没有什么不同。JavaSE第7版的新特性switch支持String由Java编译器处理，而不是JVM本身。这样的话，JavaSE第7版的其它新特性也由Java编译器处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我不认为我们需要回顾Java是如何发展的来更好的使用Java。许多的开发者没有深刻地理解JVM也开发出了很好地应用和库。但是，如果你更多地去理解JVM，这将更有助于你去解决像以上例子中的问题。<br>除了这里提到的描述，JVM还有许多的特性和技术。JVM规范提供了一个灵活的规范让JVM供应商来提供更高级的特性，许多不同的技术可以被供应商使用。尤其是垃圾收集器技术被大部分提供与VM相同的功能的语言使用，是最新的最有技术的性能。但是，因为在许多的杰出研究中已经讨论这个问题，我就不在这篇文章中详细解释这一点了。</p>
<p>如果你是韩文使用者并且需要JVM内部结构的更多信息，我建议你去阅读《Java基本性能》(Hando Kim, Seoul, EXEM, 2009)。我像参考JVM规范一样也参考了这部书来写这篇文章。如果你是英文使用者，那应该有很多涉及Java性能主题的书可以查阅。</p>
<p>last update:2018-7-16</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/04/18/JDK%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/">PREV</a><a class="next" href="/2018/03/07/%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90/">NEXT</a></div><div class="copyright"><p>© 2018 - 2022 <a href="https://kevll.com">kevin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>