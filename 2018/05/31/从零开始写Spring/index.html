<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从零开始写Spring · kev's blog</title><meta name="description" content="从零开始写Spring - kevin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://kevll.com/atom.xml" title="kev's blog"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="kev's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/kitscode" target="_blank">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从零开始写Spring</h1><div class="post-info">2018年5月31日</div><div class="post-content"><p>每一个使用Java开发的人对于Spring都再熟悉不过了，我也一直想了解它的工作机制。无奈源码不是那么容易直接阅读的，一个框架无疑是庞大和繁杂的，会有很多的细枝末节。为了避免掉进细节中出不来，只要把它的总体流程和机制理清就可以了。在搜索相关资料的时候发现了一个开源的<a target="_blank" rel="noopener" href="https://github.com/code4craft/tiny-spring">Spring构建项目</a>，作者一步一步地实现了Spring的基础功能，这对于想学习Spring的人来说真是一份福音。我在这也只是模仿，试着创建一个基础的Spring框架，记下一些自己的总结。<span id="more"></span></p>
<p>在我初步的理解中，Spring是一个IOC的容器，我们只需要给出类的定义，实例化交由Spring来管理。因为在我们自己写程序的时候，想使用其它的类或是调用其它类的功能的时候，都是直接new，这样随意的实例化对象，在一个庞大的系统中肯定是一个不安全和不节省空间的方法。在这个开源项目中，作者使用tag标注了不同阶段的进度，可以依次构建出一个简单的Spring框架。</p>
<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>创建BeanFactory就是要集中管理Bean，这里BeanFactory开放了两个接口，一个根据名称获得一个Bean的实例，还有一个就是向BeanFactory注册新的Bean。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">	</span><br><span class="line">	Object getBean(String name);</span><br><span class="line"></span><br><span class="line">	void registerBeanDefinition(String name, BeanDefinition beanDefinition) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的BeanDefinition就是对类信息进行管理的一个类，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition &#123;</span><br><span class="line">	</span><br><span class="line">	private Object bean; //bean的实例化对象</span><br><span class="line">	</span><br><span class="line">	private Class beanClass; //bean的类对象</span><br><span class="line"></span><br><span class="line">	private String beanClassName; //类的全路径</span><br><span class="line"></span><br><span class="line">	private PropertyValues propertyValues; //类的属性集合</span><br><span class="line">	</span><br><span class="line">	public BeanDefinition() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setBeanClassName(String beanClassName) &#123;</span><br><span class="line">		this.beanClassName = beanClassName;</span><br><span class="line">		try &#123;</span><br><span class="line">			this.beanClass = Class.forName(beanClassName); //根据路径加载类，初始化类对象</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...setters and getters</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个定义类将一个类能用到的所有信息都集中在一起了，再以一个&lt;name,beanDefiniton&gt;键值的形式注册到BeanFactory当中，以后不管是谁要用什么类，都去BeanFactory里取。</p>
<p>这里有一个HelloSerive类，里面有一个类型为String的text属性，一个打印text内容的helloSpring方法，让我们看看BeanFactory是如何一步步管理和实例化这个类的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSerive &#123;</span><br><span class="line">	</span><br><span class="line">	private String text;</span><br><span class="line"></span><br><span class="line">	public void helloSpring()&#123;</span><br><span class="line">		System.out.println(text);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化BeanFactory，向BeanFactory注册HelloService，然后通过名称获取HelloService并调用方法打印text：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//AutowireCapableBeanFactory是BeanFactory的实现，是一个自动装载工厂</span><br><span class="line">BeanFactory beanFactory=new AutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">//register to beanFactory						</span><br><span class="line">BeanDefinition beanDefinition=new BeanDefinition();</span><br><span class="line">beanDefinition.setBeanClassName(&quot;org.learn.test.HelloSerive&quot;);//将全路径告诉框架，由框架加载类</span><br><span class="line"></span><br><span class="line">//设置属性</span><br><span class="line">PropertyValues propertyValues = new PropertyValues();</span><br><span class="line">propertyValues.addPropertyValue(new PropertyValue(&quot;text&quot;, &quot;Hello Spring!&quot;));</span><br><span class="line">      beanDefinition.setPropertyValues(propertyValues);</span><br><span class="line"></span><br><span class="line">      //注册</span><br><span class="line">beanFactory.registerBeanDefinition(&quot;helloService&quot;,beanDefinition);</span><br><span class="line"></span><br><span class="line">//get bean and invoke helloSping method</span><br><span class="line">//获得bean都通过bean工厂</span><br><span class="line">HelloSerive helloSerive = (HelloSerive) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloSerive.helloSpring();</span><br></pre></td></tr></table></figure>

<p>之后就是对BeanFactory的实现，其中关键的几个部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Map集合储存了所有Bean对象的信息，是一个大仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBeanInstatnce(BeanDefinition beanDefinition)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line">	return beanDefinition.getBeanClass().newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据类的路径去加载类，就获得了类的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void setProperties(Object bean,BeanDefinition bd) throws Exception&#123;</span><br><span class="line">	for (PropertyValue propertyValue : bd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">		Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">		declaredField.setAccessible(true);</span><br><span class="line">		declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用反射，将类的属性注入到实例当中，这里需要注意的是：declaredField.setAccessible(true);因为text属性被private修饰，要设置访问权限为true，不然无法注入属性值。</p>
<p>之后，通过BeanFactory的getBean方法获取HelloService的实例，然后调用HelloSpring方法，就可以把text打印出来了。</p>
<h1 id="bean的配置分离"><a href="#bean的配置分离" class="headerlink" title="bean的配置分离"></a>bean的配置分离</h1><p>在阶段1的时候，我们注册bean和注入属性还要手动在代码中操作，在后期我们要将这些工作自动化，就是要将配置分离出来，这里用xml来作配置文件，可以看到类的配置如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean name=&quot;helloWorldService&quot; class=&quot;com.kevll.HelloWorldService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是我们熟悉的Spring-beans的配置了，我们习惯性的操作都是在xml中配置上bean的全路径和属性，让Spring自己去加载，然后从BeanFactory中getBean。这里基本就是读取和解析xml，用的是javax.xml.parsers和org.w3c.dom下的工具包，可以将xml文件解析成一个dom对象，然后对其中的每个节点进行操作、取值。这里就属于比较细节和繁琐的部分了，我们没必要去看Spring是怎么一步一步的解析xml文件，只需要知道最终xml中的属性都将被加载到bean的定义中就行了。以下是xml解析类的部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void doLoadBeanDefinitions(InputStream inputStream) throws Exception &#123;</span><br><span class="line">	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">	DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">	Document doc = docBuilder.parse(inputStream);//构建了xml对应的Document文件对象</span><br><span class="line">	// 解析bean</span><br><span class="line">	registerBeanDefinitions(doc);</span><br><span class="line">	inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerBeanDefinitions(Document doc) &#123;</span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	parseBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void parseBeanDefinitions(Element root) &#123;</span><br><span class="line">	NodeList nl = root.getChildNodes();</span><br><span class="line">	for (int i = 0; i &lt; nl.getLength(); i++) &#123;//遍历取节点信息</span><br><span class="line">		Node node = nl.item(i);</span><br><span class="line">		if (node instanceof Element) &#123;</span><br><span class="line">			Element ele = (Element) node;</span><br><span class="line">			processBeanDefinition(ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml解析完成后将遍历注入到BeanFactory中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String,BeanDefinition&gt; registry;//xml解析类中保存解析结果</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">			//遍历注册到beanFactory中</span><br><span class="line">			beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们可以将bean的配置与代码分离开了，实现了解耦，以后不管用哪个类，需要如何初始化这个类，都在xml中配置。</p>
<h1 id="向bean中注入bean"><a href="#向bean中注入bean" class="headerlink" title="向bean中注入bean"></a>向bean中注入bean</h1><p>之前的属性注入只是简单的基本类型，那如果属性是一个对象呢，一个用户自定义的对象。那我们就要根据这个bean的名称去BeanFactory找对应的对象，并对其进行初始化。属性包含引用的xml配置如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;outputService&quot; class=&quot;com.kevll.OutputService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;helloWorldService&quot; ref=&quot;helloWorldService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;helloWorldService&quot; class=&quot;com.kevll.HelloWorldService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;outputService&quot; ref=&quot;outputService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>可见helloWorldService的&lt;\property&gt;中使用了一个ref属性表示了引用，引用的是com.kevll.OutputService的bean name,这是在告诉解析器，我有一个com.kevll.OutputService类的属性。我们在这用一个BeanReference来表示这种引用关系，只要在xml中解析到ref，就为其加上一个属性值为BeanReference的PropertyValue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ref = propertyEle.getAttribute(&quot;ref&quot;);</span><br><span class="line">if (ref == null || ref.length() == 0) &#123;</span><br><span class="line">	throw new IllegalArgumentException(&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span><br><span class="line">			+ name + &quot;&#x27; must specify a ref or value&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BeanReference beanReference = new BeanReference(ref);</span><br><span class="line">beanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, beanReference));</span><br></pre></td></tr></table></figure>
<p>在我们注入属性时，如果检测到属性为一个引用，也要去BeanFactory中获得这个引用的实例，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object value = propertyValue.getValue();</span><br><span class="line">if (value instanceof BeanReference) &#123;</span><br><span class="line">	BeanReference beanReference = (BeanReference) value;</span><br><span class="line">	value = getBean(beanReference.getName());</span><br><span class="line">&#125;</span><br><span class="line">declaredField.set(bean, value);</span><br></pre></td></tr></table></figure>

<p>这里对BeanFactory还有一个优化，延后了bean的实例化，实现了懒加载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws Exception&#123;</span><br><span class="line">	BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">	if (beanDefinition == null) &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;No bean named &quot; + name + &quot; is defined&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = beanDefinition.getBean();</span><br><span class="line">	if (bean == null) &#123;//如果BeanFacoty没有该类，再去加载</span><br><span class="line">		bean = doCreateBean(beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerBeanDefinition(String name, BeanDefinition beanDefinition) throws Exception&#123;</span><br><span class="line">	//Object bean = doCreateBean(beanDefinition);此方法被延后，注册时并不实例化，为了实现懒加载</span><br><span class="line">	//beanDefinition.setBean(bean);</span><br><span class="line">       beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">       beanDefinitionNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也保留了预加载的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//预加载</span><br><span class="line">public void preInstantiateSingletons() throws Exception &#123;</span><br><span class="line">	for (Iterator it = this.beanDefinitionNames.iterator(); it.hasNext();) &#123;</span><br><span class="line">		String beanName = (String) it.next();</span><br><span class="line">		getBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test中，读取xml配置并预加载类，调用helloWorld方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line">	// 1.读取配置</span><br><span class="line">	XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());</span><br><span class="line">	xmlBeanDefinitionReader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">	// 2.初始化BeanFactory并注册bean</span><br><span class="line">	AutowireCapableBeanFactory beanFactory = new AutowireCapableBeanFactory();</span><br><span class="line">	for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">		beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beanFactory.preInstantiateSingletons();//预加载，关闭就是懒加载，在显示地getBean()时才去加载Bean</span><br><span class="line"></span><br><span class="line">	// 3.获取bean</span><br><span class="line">	HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">	helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引入ApplicationContext"><a href="#引入ApplicationContext" class="headerlink" title="引入ApplicationContext"></a>引入ApplicationContext</h1><p>我们先来看一下引入ApplicationContext后的方法调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    HelloWorldService helloWorldService =(HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">    helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里应该就非常眼熟了，我们将读取xml配置和向BeanFactory中注册bean的操作再进一步的包装起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String configLocation) throws Exception &#123;</span><br><span class="line">	this(configLocation, new AutowireCapableBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassPathXmlApplicationContext(String configLocation, AbstractBeanFactory beanFactory) throws Exception &#123;</span><br><span class="line">	super(beanFactory);</span><br><span class="line">	this.configLocation = configLocation;</span><br><span class="line">	refresh();//默认为预加载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh() throws Exception &#123;</span><br><span class="line">	XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());</span><br><span class="line">	xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line">	for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">		beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们只需要告诉ApplicationContext配置文件xml的路径，所有的一切工作将由这个小Spring框架自动完成，我们只需要配置好xml，调用getBean，调用我们需要的方法就可以了。至此，Spring的IOC基本完成了，接下来的阶段就是AOP的实现了。</p>
<h1 id="引入Advice和Joinpoint"><a href="#引入Advice和Joinpoint" class="headerlink" title="引入Advice和Joinpoint"></a>引入Advice和Joinpoint</h1><p>这里使用的是AOP联盟提供的内容，现在pom中加入相关依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;aopalliance&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>接下来要用到MethodInterceptor、MethodInvocation这两个接口，它们分别继承自Advice和Joinpoint。Advice作为增强，是在方法的周围增加自定义的操作。Joinpoint作为切入点，可以将新的行为从这些点插入到程序的正常的流程中。</p>
<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>为了使用这两个功能，可以利用一个JDK提供的动态代理的功能，在反射包下有一个Proxy类，里有方法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] &#123; advised.getTargetSource()</span><br><span class="line">				.getTargetClass() &#125;, this);</span><br></pre></td></tr></table></figure>
<p>此方法可通过代理类的类加载器、具体代理接口和InvocationHandler接口，创建一个代理类，InvocationHandler就是代理之后，在代理类调用方法时，实际拦截和调用的方法。InvocationHandler里是一个invoke方法，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123;</span><br><span class="line">	MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">	return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span><br><span class="line">			args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有我们自定义的一个MethodInterceptor，放在了advised中，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TimerInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        long time = System.nanoTime();</span><br><span class="line">        System.out.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; start!&quot;);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; end! takes &quot; + (System.nanoTime() - time)</span><br><span class="line">                + &quot; nanoseconds.&quot;);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invocation.proceed()是执行真实的方法，可以看到我们在真实方法调用的前后各打印了method start和method end两句话，完成了新行为的添加。<br>ReflectiveMethodInvocation是一个自定义的包装类，里面包含了代理类的实例和方法信息。它本身实现了MethodInvocation接口，向上就是Joinpoint接口，由它提供proceed()方法，其实就是method.invoke()调用。至此就可以基于JDK动态代理完成AOP功能了，完整JDK代理的调试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 设置被代理对象(Joinpoint)</span><br><span class="line">AdvisedSupport advisedSupport = new AdvisedSupport();</span><br><span class="line">TargetSource targetSource = new TargetSource(helloWorldService, HelloWorldService.class);</span><br><span class="line">advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">// 2. 设置拦截器(Advice)</span><br><span class="line">TimerInterceptor timerInterceptor = new TimerInterceptor();</span><br><span class="line">advisedSupport.setMethodInterceptor(timerInterceptor);</span><br><span class="line"></span><br><span class="line">// 3. 创建代理(Proxy)</span><br><span class="line">JdkDynamicAopProxy jdkDynamicAopProxy = new JdkDynamicAopProxy(advisedSupport);</span><br><span class="line">HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.getProxy();</span><br><span class="line"></span><br><span class="line">// 4. 基于AOP的调用</span><br><span class="line">helloWorldServiceProxy.helloWorld();</span><br></pre></td></tr></table></figure>

<h1 id="使用AspectJ管理切面"><a href="#使用AspectJ管理切面" class="headerlink" title="使用AspectJ管理切面"></a>使用AspectJ管理切面</h1><p>切面是通知和切点的结合，用来更方便的管理AOP的执行。AspectJ最早是一门语言，它的Poincut表达式被Spring借鉴了过来，因此我们可以实现一个AspectJExpressionPointcutAdvisor，利用表达式对需要代理的类进行筛选。我们可以用MethodMatcher测试一下方法和表达式是否匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMethodInterceptor() throws Exception &#123;</span><br><span class="line">    String expression = &quot;execution(* com.kevll.*.*(..))&quot;;</span><br><span class="line">    AspectJExpressionPointcut aspectJExpressionPointcut = new AspectJExpressionPointcut();</span><br><span class="line">    aspectJExpressionPointcut.setExpression(expression);</span><br><span class="line">    boolean matches = aspectJExpressionPointcut.getMethodMatcher().matches(HelloWorldServiceImpl.class.getDeclaredMethod(&quot;helloWorld&quot;),HelloWorldServiceImpl.class);</span><br><span class="line">    Assert.assertTrue(matches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="将AOP植入Spring的Bean创建过程"><a href="#将AOP植入Spring的Bean创建过程" class="headerlink" title="将AOP植入Spring的Bean创建过程"></a>将AOP植入Spring的Bean创建过程</h1><p>我们不能每次使用AOP都来手动构建代理，最终还是要将一切过程自动化。在xml中配置Bean、配置Advice和表达式，让Spring帮我们完成筛选和代理的过程，所以我们要将AOP和代理植入Bean的创建过程。这里主要用到BeanPostProcessor接口，对Bean的创建进行无侵害式的植入。可以将通知和表达式的配置写在xml中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;aspectjAspect&quot; class=&quot;com.kevll.aop.AspectJExpressionPointcutAdvisor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;advice&quot; ref=&quot;timeInterceptor&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;expression&quot; value=&quot;execution(* com.kevll.*.he*(..))&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>BeanPostProcessor接口如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception;</span><br><span class="line"></span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是两个方法，分别在Bean初始化之前和之后进行操作，我们可以将这里的方法放在BeanFactory的getBean方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws Exception&#123;</span><br><span class="line">    BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">    if (beanDefinition == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No bean named &quot; + name + &quot; is defined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = beanDefinition.getBean();</span><br><span class="line">    if (bean == null) &#123;</span><br><span class="line">        bean = doCreateBean(beanDefinition);</span><br><span class="line">        bean = initializeBean(bean, name);//植入BeanProcessor</span><br><span class="line">        beanDefinition.setBean(bean);//用代理类代替原来的类</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的initializeBean就是执行postProcessAfterInitialization方法对Bean生成代理类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception &#123;</span><br><span class="line">    if (bean instanceof AspectJExpressionPointcutAdvisor) &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof MethodInterceptor) &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory.getBeansForType(AspectJExpressionPointcutAdvisor.class);</span><br><span class="line">    for (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">        if (advisor.getPointcut().getClassFilter().matches(bean.getClass())) &#123;//匹配需要代理的类</span><br><span class="line">            AdvisedSupport advisedSupport = new AdvisedSupport();</span><br><span class="line">            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">            TargetSource targetSource = new TargetSource(bean, bean.getClass().getInterfaces());</span><br><span class="line">            advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">            return new JdkDynamicAopProxy(advisedSupport).getProxy();//返回JDK动态代理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在执行调用方法的时候拦截方法，匹配一下是否要对方法进行增强：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123;</span><br><span class="line">    MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">    //对切点的匹配</span><br><span class="line">    if (advised.getMethodMatcher() != null &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">        return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),</span><br><span class="line">                method, args));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，在xml配置过增强和切面后，再和平常一样调用helloWorld方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    HelloWorldService helloWorldService =(HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">    helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以得到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Invocation of Method helloWorld start!</span><br><span class="line">Hello World!</span><br><span class="line">Invocation of Method helloWorld end! takes 830130 nanoseconds.</span><br></pre></td></tr></table></figure>
<p>从而完成AOP的植入。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/06/06/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B--%E7%AE%80%E8%BF%B0%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">PREV</a><a class="next" href="/2018/04/18/JDK%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/">NEXT</a></div><div class="copyright"><p>© 2018 - 2022 <a href="https://kevll.com">kevin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>