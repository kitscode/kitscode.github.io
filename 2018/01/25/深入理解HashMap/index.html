<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入理解HashMap · kev's blog</title><meta name="description" content="深入理解HashMap - kevin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://kevll.com/atom.xml" title="kev's blog"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="kev's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/kitscode" target="_blank">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入理解HashMap</h1><div class="post-info">2018年1月25日</div><div class="post-content"><p>之前浅显地了解过HashMap是由数组加上链表实现的，但是一直没有真正理解到他的结构到底是怎样的，现在记录下自己学习HashMap的过程和理解，本篇研究了put与resize的源码实现、HashMap的关于桶大小及扩展的一些细节、以及jdk1.8做了哪些优化。<span id="more"></span><!-- more --></p>
<h2 id="数组与链表的结合"><a href="#数组与链表的结合" class="headerlink" title="数组与链表的结合"></a>数组与链表的结合</h2><p>在之前的学习中，了解到数组在内存中是一组连续的存储。它便于遍历和查询，但是不方便插入和删除。例如在一个存储了100个元素的ArrayList中，在索引为50的位置插入一个元素，则从索引为50开始往后的所有元素都需要后移，这无疑是非常大的消耗。但数组的查找时间复杂度小，为O(1)。而链表是一种离散的存储，插入和删除只需要修改链接的指向，但搜索的时间复杂度达到O(n)。<br>所以在HashMap中结合了两者的特性，让HashMap成为了一种寻址容易，插删也容易的数据结构。在这里用到的就是哈希表，哈希表为了解决冲突，主要有两种实现方法：开放地址法和链地址法。在HashMap中使用的是链地址法，也可称为拉链法，可理解为“链表的数组”。</p>
<p>HashMap中，有一个重要的Node[] table，Node实现了Map的静态内部类Entry，其中重要的属性有key，value，next，保存的就是键值对和到下一个Node的引用。</p>
<h2 id="put与get的基本操作"><a href="#put与get的基本操作" class="headerlink" title="put与get的基本操作"></a>put与get的基本操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//存储</span><br><span class="line">int hash=key.hashCode();</span><br><span class="line">int index=hash&amp;(Entry[].length-1);</span><br><span class="line">Entry[index]=value;</span><br><span class="line">//取值</span><br><span class="line">int hash=key.hashCode();</span><br><span class="line">int index=hash&amp;(Entry[].length-1);</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure>
<p>这样，就基本将键值对均匀的分布在了数组中。<br>如果两个key经过hash后得到的index相同，会发生什么？例如Entry[0]&#x3D;A之后，又来了一个元素B，其经过运算后的index也是0。这时就要用到链表的结构了，前面说道Entry有一个为next的属性，所以此时B.next&#x3D;A，Entry[0]&#x3D;B。Entry[0]处将一直存储着最后插入的元素。</p>
<h2 id="代码详细剖析"><a href="#代码详细剖析" class="headerlink" title="代码详细剖析"></a>代码详细剖析</h2><p>jdk1.8，put-&gt;putVal</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;    //HashMap的元素数组</span><br><span class="line">    Node&lt;K,V&gt; p;        //数组中准备插入的索引位置的原始Node</span><br><span class="line">   </span><br><span class="line">    int n, i;           //n：元素数组的长度，i：准备插入的经过hash运算过后的索引值</span><br><span class="line">    </span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0) //如果元素数组为null或长度为0，则resize</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)          //如果原索引处为空，新建一个Node</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;    //原始key</span><br><span class="line">        </span><br><span class="line">        //如果索引处有原始Node，且key值相同，赋给e</span><br><span class="line">        if (p.hash == hash &amp;&amp;   </span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) </span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        //如果为TreeNode，直接插入红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        //遍历链表准备插入</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                //如果Node的next为空，插入next</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果链表的长度超过了阈值（默认为8），转为红黑树处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果插入元素与next的key值相同，直接覆盖</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                //链表后移一位</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ++modCount;  //表结构修改次数增加</span><br><span class="line">   </span><br><span class="line">    if (++size &gt; threshold)  //如果增加后的元素数目超过了阈值，则resize</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.8的扩容代码好像有点复杂，包含红黑树，先分析一下jdk1.7的resize</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;         </span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //如果元素超过了最大容量1&lt;&lt;20(2^30) 1048576</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transfer()将原有Entry数组的元素拷贝至新的容量更大的数组。拷贝后旧数组同一条Entry链上的元素可能将被放到不同位置上，因为元素的索引都经过了重新计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">   int newCapacity = newTable.length;</span><br><span class="line">   for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">      if (e != null) &#123;</span><br><span class="line">        src[j] = null;//释放原数组索引位置对象，等待回收</span><br><span class="line">        do &#123;</span><br><span class="line">           Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">           int i = indexFor(e.hash, newCapacity); //重新计算索引</span><br><span class="line">           e.next = newTable[i]; //头插入，新元素.next指向原第一位元素(第一次指向null)</span><br><span class="line">           newTable[i] = e;      //将最新的元素放在数组第一位</span><br><span class="line">           e = next;             //遍历后移</span><br><span class="line">           &#125; while (e != null);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容量与负载因子"><a href="#容量与负载因子" class="headerlink" title="容量与负载因子"></a>容量与负载因子</h2><p>在HashMap中，有两个重要的值，它们是桶容量和负载因子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<p>默认的初始容量是16、负载因子是0.75。HashMap当前能存放的最大数据量threshold&#x3D;(容量*负载因子)，超过这个数据量就要进行扩容，扩容后是之前容量的2倍。默认的0.75负载因子是一个对时间和空间的均衡，一般的情况下都不需要修改，如果场景比较特殊，比如内存很多而对时间效率要求高就可以降低负载因子的值；而如果内存紧张对时间效率要求也不高的话就可以增加负载因子的值，这个值可以超过1。</p>
<h2 id="2次方桶的作用"><a href="#2次方桶的作用" class="headerlink" title="2次方桶的作用"></a>2次方桶的作用</h2><p>在HashMap中，哈希桶的大小必须是2的N次方（一定是合数）。一般情况下，素数导致冲突的概率要小于合数，HashTable初始化桶的大小为11就是素数的应用。HashMap这样设计是为了在hash取模和扩容的时候做优化。接下来看下HashMap的hash算法和扩容机制，下面是hash算法与优化的取模运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//HashMap在put值的时候，将先执行一遍hash算法，计算hash</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">//hash算法</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//取模，1.8没有这个方法，取模运算放在了具体调用的地方</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在平均一批元素的时候，我们常常的操作就是直接对容器的容量大小进行取模运算，这样元素的分布式相对比较均匀的。但是在计算机中模运算的消耗是比较大的，当桶的大小是2的n次方时，总有h%length &#x3D; h&amp;(length-1)。这个取模运算的效率是非常重要的，因为在put和get时，对元素的索引进行计算的时候都要经过这个方法，而&amp;比%有更高的效率。</p>
<p>hash算法越分散均匀，hash碰撞的概率就越小，map的存取效率就越高。</p>
<p>1.8之后，使用的是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。所以，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805">美团点评技术团队：Java8系列之重新认识HashMap</a><br><a target="_blank" rel="noopener" href="https://monkeysayhi.github.io/2017/08/26/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">猴子007：HashMap实现原理</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/softidea/p/7261111.html">沧海一滴：深入理解HashMap</a><br>jdk1.7, jdk1.8 源码</p>
<p>last update: 2018-06-27</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84O(nlogn)%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84/">PREV</a></div><div class="copyright"><p>© 2018 - 2022 <a href="https://kevll.com">kevin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>