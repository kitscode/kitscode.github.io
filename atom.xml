<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kev&#39;s blog</title>
  
  
  <link href="https://kevll.com/atom.xml" rel="self"/>
  
  <link href="https://kevll.com/"/>
  <updated>2022-03-13T10:42:31.710Z</updated>
  <id>https://kevll.com/</id>
  
  <author>
    <name>kevin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>About CAP</title>
    <link href="https://kevll.com/2020/06/09/About%20CAP/"/>
    <id>https://kevll.com/2020/06/09/About%20CAP/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2022-03-13T10:42:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>在如今的互联网应用体系架构中，因系统的庞大和复杂程度，一个系统往往会被拆分为不同的子系统，这样便于水平扩展和解耦。但是同时也增加了整个系统的复杂性，因为不同的子系统通过网络通信，而网络又是不可靠的，如何在这种环境下保证各节点数据备份的一致性；而若干个子系统的崩溃又如何保证整个系统的可用性；这都是一个分布式系统需要考虑和解决的问题。此篇作为分布式入门，讨论一下经典的CAP理论，和一些基础的分布式系统下的概念、问题和解决方案。</p><span id="more"></span><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>在2000年，Eric Brewer在PODC（Principles of Distributed Computing）的研讨会上首次提出了CAP的概念，含义如下：</p><ul><li>C：Consistency，一致性，多个节点在系统运行中是否时刻能保证数据一致的特性。</li><li>A：Availability，可用性，系统必须一直保持可用状态，“可用状态”指的是用户的每一个操作需要在指定的时间内得到反馈，无论成功或失败。</li><li>P：Partition Tolerant，分区容错性，在遇到网络分区故障的时候，整个系统仍然能够保持服务。</li></ul><p>他还提到了一点就是：任何一个分布式系统都无法同时满足CAP中的三个条件，最多只能做到两项。即CA、AP或CP。一般来说分区容错性是个最基本的要求，所以通常在C和P之间寻求平衡。但其实Eric在2012年曾指出这个观点在实际的系统设计指导上有一定的误导性，过于简单化地描述了分布式系统设计中的问题，实际情况要复杂得多，还要看具体需求而定。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论基于CAP演化而来，它的核心思想是：<strong>即使无法达到强一致性，每个应用和业务都应当采取适当的方式来达到最终一致性。</strong>其中BASE的含义如下：</p><ul><li>BA：Basically Available，基本可用，即使有部分系统无法响应，也不影响基本可用性，可以损失一定的响应时间，或是将用户重定向到降级页面。</li><li>S：Soft state，柔性状态，允许不同节点的数据同步存在一定的延迟。</li><li>E：Eventually consistent，最终一致性，所有节点的数据副本在一定时间后都能达到一致的状态。</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式环境不同于以往的单机环境，可以使用传统的方法在单进程内对多线程进行管理。由于客户端在不同的机器上，不同的网络环境下，此时对并发情况下资源共享的处理就要用到一些其他的方式来做互斥了，通常我们会借用一些第三方软件来实现一个“分布式锁”，常见的实现方式有如下几种：</p><ul><li>基于数据库：建立锁表，使用表的唯一约束特性实现获取锁的逻辑。</li><li>基于Redis：使用setnx、key-value-UUID方式实现加锁。</li><li>基于Zookeeper：建立资源目录，根据子节点实现资源加锁。</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>当一个系统被拆分成不同的子系统时，其数据库必定也会被拆分，在这种情况下，如何保证业务的顺利执行呢？也就是如何实现分布式环境下的“事务”，其中有以下实现方案可以提供给我们一点思路：</p><ul><li>2PC：Two phase commit，两阶段提交，第一阶段投票，各节点执行事务，写本地log，但不提交。第二阶段提交，满足所有节点运行正常时进行commit通知，否则全部回滚。</li><li>3PC：Three phase commit，三阶段提交，比两阶段提交多了一个预询盘阶段，该阶段管理者会依此询问各个节点是否可以正常执行事务，是一个很轻量的操作。</li><li>Paxos算法：一种一致性算法。</li></ul><p>2PC保护了数据一致性，在分布式系统设计中有大概三种一致性的区别：</p><ul><li>强一致性：在任意时刻，所有节点的数据都是一致的。</li><li>弱一致性：数据更新后的一段时间里，能接受部分数据访问不了，则为弱一致性。</li><li>最终一致性：不用保证任意时刻数据的一致性，但是随着时间的迁移，各节点的数据会趋向最终一致性。</li></ul><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>传统事务：ACID，刚性事务，强调强一致性，即同步操作。柔性事务：弱一致性，要达到最终一致性，可以异步操作。总的来说柔性事务是利用相关业务的弹性，找到业务上对于事务过程中的不一致的容忍程度，最后找到时效和功能完整的平衡点。可分为四种不同的柔性事务：</p><ul><li>两阶段型：两阶段提交的典型模式，对应技术上的XA、JTA&#x2F;JTS。</li><li>补偿型：TCC型事务（Try-Confirm-Cancel），一个事务分为AB两个操作，在两台机器上执行。如果A执行顺利，那么就提交，如果B执行顺利也提交顺利了，那么整个事务算完成了。如果B失败了，那么就要对操作A进行补偿，也就是undo操作。</li><li>异步确保型：将一些同步的操作变为异步的，避免对数据库事务的争用，比如批量记账处理。</li><li>最大努力通知型：通过通知服务器进行，允许失败，有补充机制。例如：客户交易结果通知重试、补单重试。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式架构为系统的扩大和拓展提供了方便性，但是也带来了很大的复杂性，如何保证数据的一致性和系统的可用性，都是需要长期研究和探讨的话题。我们需要在业务可以接受的“Soft State”上和数据的一致性时效上做平衡和选择，也要做好各种异常的补偿措施，然后在实际应用中检验成效。</p><p>参考：<br><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">分布式事务，这一篇就够了</a><br><a href="https://www.zhihu.com/question/31813039">支付宝运营架构中柔性事务指的是什么</a><br><a href="https://zhuanlan.zhihu.com/p/35616810">分布式一致性之两阶段提交协议、三阶提交协议</a><br><a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">分布式锁的实现之redis篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在如今的互联网应用体系架构中，因系统的庞大和复杂程度，一个系统往往会被拆分为不同的子系统，这样便于水平扩展和解耦。但是同时也增加了整个系统的复杂性，因为不同的子系统通过网络通信，而网络又是不可靠的，如何在这种环境下保证各节点数据备份的一致性；而若干个子系统的崩溃又如何保证整个系统的可用性；这都是一个分布式系统需要考虑和解决的问题。此篇作为分布式入门，讨论一下经典的CAP理论，和一些基础的分布式系统下的概念、问题和解决方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://kevll.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>理解GC算法与收集器</title>
    <link href="https://kevll.com/2019/10/02/%E7%90%86%E8%A7%A3GC%E7%AE%97%E6%B3%95%E4%B8%8E%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://kevll.com/2019/10/02/%E7%90%86%E8%A7%A3GC%E7%AE%97%E6%B3%95%E4%B8%8E%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.167Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言最独有的特点之一就是有一套自治的内存管理模型，即JVM（Java Virtual Memory），它帮助我们管理对象的生存周期，所以我们在平时的开发任务中可以专注于功能的具体实现。在JVM有一个称为GC（Garbage Collection）的关键过程，它将会按照一定的规则去整理和清除内存中的对象。本文整理了几种不同的GC算法，学习它们将帮助我们了解当一个Java程序运行起来的时候，JVM到底是怎样管理内存的。<span id="more"></span></p><blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。  – 《深入理解JVM》</p></blockquote><p>JVM运行起来的时候，其内存主要分为6个部分，其中堆（Heap）是JVM存储大量对象的一块共享的内存，也是占比最大的一块区域，GC的主要工作就是对这块内存进行管理。如下图所示：<br><img src="/191002_runtime_areas.png" alt="图1：运行时数据区域"></p><h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2><p>JVM如何判断一个对象是否需要被回收？主流的实现是通过一个叫可达性分析的方法来判定的，JVM会定义一系列的“GC Roots”，包含以下几种：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常亮引用的对象</li><li>本地方法栈JNI（Native方法）引用的对象</li></ul><p>从这些Roots开始向下搜索，走过的路程称为引用链，如果一个对象找不到一条引用链来与Roots相连的话，那它就将被第一次标记。确认需要被回收需要两次标记，第二次则是在一个称为F-Queue的队列中，JVM将会执行对象的finalize方法，如果方法执行完后该对象还是没有与GC Roots相连，则会被第二次标记，等待GC的回收（finalize方法在jdk9中已被置为Deprecated）。当GC开始工作的时候，这些可以被回收的对象就会按照一定规则被清理掉了，以下是常用的四种GC算法：</p><h3 id="1-标记清除（Mark-Sweep）"><a href="#1-标记清除（Mark-Sweep）" class="headerlink" title="1.标记清除（Mark-Sweep）"></a>1.标记清除（Mark-Sweep）</h3><p>标记清除是最基本的一种GC算法，首先就是标记好需要清理的对象，上文已经阐述过，紧接着第二步就是要把它们所占的内存清理掉。这个算法主要的问题就是在清除过后会留下大量不连续的内存空间，不利于在之后的程序中分配比较大的对象。</p><h3 id="2-复制（Copying）"><a href="#2-复制（Copying）" class="headerlink" title="2.复制（Copying）"></a>2.复制（Copying）</h3><p>复制算法将JVM的内存切分为两个同样大的部分，程序使用的时候只使用其中的一个，当需要GC的时候，就把使用中的那一半内存里的存活对象复制到另一半内存，并且按顺序排列。它解决了内存碎片的问题，但是能使用的内存空间被减少了一半，代价过高。</p><h4 id="复制算法在新生代的使用"><a href="#复制算法在新生代的使用" class="headerlink" title="复制算法在新生代的使用"></a>复制算法在新生代的使用</h4><p>现在大部分虚拟机都用复制算法回收新生代，因为新生代的存活率并不高，所以实际上内存不是对半划分的，内存会被分为一块较大的Eden空间和两块较小的Survivor空间，他们的比率是8:1，每次使用Eden和其中一块Survivor来存放对象，当发生GC的时候就把存活下来的对象拷贝到另一个Survivor中，如此反复。</p><h3 id="3-标记整理（Mark-Compact）"><a href="#3-标记整理（Mark-Compact）" class="headerlink" title="3.标记整理（Mark-Compact）"></a>3.标记整理（Mark-Compact）</h3><p>标记整理类似于标记清除，不同的是所有的存活对象会被重新整理，重新占连续的内存，以便清除内存碎片。</p><h3 id="4-分代收集（Generational-Collection）"><a href="#4-分代收集（Generational-Collection）" class="headerlink" title="4.分代收集（Generational Collection）"></a>4.分代收集（Generational Collection）</h3><p>分代收集主要是将内存分为了新生代和老年代，并且结合了前面几种GC算法，在不同的代区中使用不同的算法。例如在新生代，由于一般情况下90%以上的新对象都不会持久，所以使用复制算法，只需要复制一小部分的存活对象即可。而因为老年代里，对象存活率比较高则使用标记清理或标记整理的算法来清除。</p><h2 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h2><p>收集器就是结合这些GC算法的具体实现了，没有万能的收集器，只有在不同的场景下使用合适的收集器。以下讨论的收集器是基于JDK1.7Update14之后的HotSpot虚拟机，如下图所示：（有连线的表示可以搭配使用）<br><img src="/191002_hotspot_collectors.png" alt="图2：HotSpot的收集器"></p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><p>Serial收集器是最基本的一款收集器，它是单线程工作的，而且工作的时候需要暂停所有的其它的用户线程，直到收集完毕。它的优势是简单有效，但是Stop The World时间太长不太友好，对于单个CPU以Client模式运行的虚拟机是个不错的选择。</p><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><p>ParNew是Serial的多线程版本，在新生代中只有它和Serial能与老年代的CMS收集器搭配使用。</p><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3><p>Parallel Scavenge是一个关注吞吐量的收集器，吞吐量指的是：用户线程的执行时间&#x2F;(用户线程的执行时间+GC时间)。它提供自定义设置来动态控制吞吐量，例如要是关注GC停顿时间的话，使用-XX:MaxGCPauseMillis去控制GC停顿的最大时间，这个时候新生代空间将会缩小，相对的GC的频率也会变高点。要是关注吞吐量，则可以使用-XX:GCTimtRatio来直接控制最大吞吐量，虚拟机会根据当前系统信息动态调整状态以趋近于这个吞吐量。</p><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h3><p>Serial Old是Serial的老年代版本，它可以与Parallel Scavenge搭配使用，或作为CMS的后背预案。</p><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge的老年代版本，在JDK1.6开始提供，之后在注重吞吐量或CPU资源敏感的场合都可以直接选取这两种搭配了。</p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h3><p>CMS（Concurrent Mark Sweep）的特点是：并发收集、低停顿，也可称为低停顿收集器（Concurrent Low Pause Collector）。</p><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><p>G1是目前最前沿的一款收集器，被视为JDK1.7中HotSpot的一个重要的进化特征。G1将整个Java堆划分为多个大小相同的区域，它跟踪每个区域里面的垃圾堆积的价值大小，每次根据允许的收集时间，优先回收价值最大的区域。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java语言最独有的特点之一就是有一套自治的内存管理模型，即JVM（Java Virtual Memory），它帮助我们管理对象的生存周期，所以我们在平时的开发任务中可以专注于功能的具体实现。在JVM有一个称为GC（Garbage Collection）的关键过程，它将会按照一定的规则去整理和清除内存中的对象。本文整理了几种不同的GC算法，学习它们将帮助我们了解当一个Java程序运行起来的时候，JVM到底是怎样管理内存的。</summary>
    
    
    
    
    <category term="JVM" scheme="https://kevll.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>事务的ACID及其实现</title>
    <link href="https://kevll.com/2019/09/16/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>https://kevll.com/2019/09/16/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.163Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，后端的实质就是操作数据，储存数据，那就要与各种数据库打交道。在数据库中，为了保证数据的一致性，规定了一个“事务”的概念，它是一系列数据库操作的集合。ACID是事务的四个重要的特性，理解这四个特性及它们的实现原理可以在一定程度上理解数据库到底是怎样工作的。<span id="more"></span></p><h2 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity(原子性)"></a>Atomicity(原子性)</h2><blockquote><p>在一个事务中的若干个数据库操作，要么全部执行成功，要么全部不执行。任何时候，事务为一个整体，是一个不可被打断的一个操作集合。</p></blockquote><p>在一个事务的执行中，如果遇到异常，则需要进行一种叫做“回滚”的操作，它会对已经执行过的操作进行回滚，从而保证数据回到这一系列操作集合都没有被执行的状态。Mysql中，所有的数据库操作都会先被记录到一个回滚日志(undo log)中，然后再将数据写入磁盘。这个回滚日志是一个逻辑日志，对应着实际修改语句的反向操作，例如insert语句对应的就是delete语句，update语句对应一条相反的update。这样在程序发现异常的时候，数据库就可以执行这些语句，尝试将数据恢复到事务执行之前的样子，从而保证事务操作的原子性。<br>值得注意的是，事务只能保证对数据库操作的原子性，如果在事务中有其它的操作，例如向其它系统发送一条消息、向用户发送邮件，这些都是无法再撤销的，需要开发者去解决这些问题。（我自身就处理过这样的问题，当时要在事务结束的时候发送一条扣款的MQ，但是当程序发生异常需要回滚的时候，这条发出去的消息就无法撤销了。所以要将这个操作放在最后执行，尽量也要放在事务之外，防止消费者在操作这条消息的时候拿到的是前者事务还未提交的数据。</p><h2 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability(持久性)"></a>Durability(持久性)</h2><blockquote><p>事务被提交后，需要保证被改变数据的持久性，即使数据库出现故障，例如宕机或停电都不会受影响。</p></blockquote><p>事务的持久性也是通过日志来实现，Mysql中用重做日志(redo log)记录了一个事务内的所有数据库操作。这些操作会先被记到日志中，然后将改变写入数据库。日志也是记在硬盘上的，在发生错误时，数据库可以重新从重做日志中找到相应的信息来继续执行操作，从而保证事务的持久性。</p><h2 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation(隔离性)"></a>Isolation(隔离性)</h2><blockquote><p>并发访问数据库的时候，一个事务的操作不受其它的事务影响，并发的多个事务间保持相互独立。</p></blockquote><p>在实际的情况下，对数据的访问不会是串行的，通常是多个线程或者多个进程同时访问同一行数据。那么这个时候谁拿到什么样的数据，就是数据库要进行控制的内容，这也是一个比较复杂的内容，因为涉及到了并发和数据一致性的问题。数据库实现了几种并发情况下对数据库访问的规则，分为了四个不同的级别，它们称为事务的隔离级别。它们是：</p><ol><li>Read Uncommited</li><li>Read Commited</li><li>Repeatable Read</li><li>Serialize</li></ol><p>需要注意的是，随着隔离级别越来越高，数据库处理并发事务的性能也越来越低，到了最后的Serialize就是把所有的并行操作当作串行来操作了。这些隔离级别并不能保证你读到的数据就是对的，它只是确定了在并发的情况下以怎样的方式去读取数据。隔离级别的实现就是使用并发控制，这里介绍两种常见的实现：</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>数据库一般有两种锁，共享锁和互斥锁，又称为读锁和写锁。共享锁是相互兼容的，它允许多个事务进行并发的读操作，而互斥锁顾名思义，是相互排斥的，同一时刻只能有一个事务拿到这把锁。从而实现并行读，串行写的数据操作效果。</p><h3 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h3><p>在Mysql中有一个叫MVCC的的实现，其中官方文档描述如下：</p><blockquote><p>Acronym for “multiversion concurrency control”. This technique lets InnoDB transactions with certain isolation levels perform consistent read operations; that is, to query rows that are being updated by other transactions, and see the values from before those updates occurred. This is a powerful technique to increase concurrency, by allowing queries to proceed without waiting due to locks held by the other transactions.<br>This technique is not universal in the database world. Some other database products, and some other MySQL storage engines, do not support it.</p></blockquote><p>文中意思就是这个称为“多版本并发控制”的机制，可以在特定隔离级别下保证事务一致性地去读取数据。就是查询正在被其它事务更新的数据的原始值，这样增强了数据库的并发事务的处理能力，查询操作不需要等待其它事务释放锁。</p><h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency(一致性)"></a>Consistency(一致性)</h2><blockquote><p>事务的一致性是一个比较特殊的属性，它需要数据库和开发者来共同实现。在事务执行的前后，数据从一个正确的状态迁移至另一个正确的状态。其中正确的状态指的是数据本身的约束及应用层的约束保持不被破坏。</p></blockquote><h3 id="数据本身的约束："><a href="#数据本身的约束：" class="headerlink" title="数据本身的约束："></a>数据本身的约束：</h3><p>数据本身应当保证正确性，例如不可被改变为其它类型，不可破坏主键约束，不可破坏唯一性以及其它在表设计完后已经规定好的约束。</p><h3 id="应用层的约束："><a href="#应用层的约束：" class="headerlink" title="应用层的约束："></a>应用层的约束：</h3><p>例如在表中有余额字段，其应用层的正确性，或者说是业务层的正确性就是该值不能小于0，如果该字段在数据库中没有不小于0的约束的话，这个数据的正确性只能由开发者保证。</p><blockquote><p>在事务执行的时候，也要保证别的事务读取数据的正确性和一致性，也就是事务操作数据的中间状态对其它事务不可见。</p></blockquote><p>参考：<br><a href="https://draveness.me/mysql-transaction">『浅入深出』MySQL 中事务的实现</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/glossary.html">Mysql术语表</a><br><a href="https://www.zhihu.com/question/31346392">如何理解数据库事务中的一致性的概念？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在软件开发中，后端的实质就是操作数据，储存数据，那就要与各种数据库打交道。在数据库中，为了保证数据的一致性，规定了一个“事务”的概念，它是一系列数据库操作的集合。ACID是事务的四个重要的特性，理解这四个特性及它们的实现原理可以在一定程度上理解数据库到底是怎样工作的。</summary>
    
    
    
    
    <category term="数据库" scheme="https://kevll.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>理解工厂模式</title>
    <link href="https://kevll.com/2019/08/04/%E7%90%86%E8%A7%A3%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kevll.com/2019/08/04/%E7%90%86%E8%A7%A3%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2022-03-13T10:15:42.703Z</updated>
    
    <content type="html"><![CDATA[<p>工厂设计模式是众多设计模式当中我最早接触的设计模式，也是一种应用最为广泛的设计模式，属于创建型设计模式。在Spring框架中，也有很经典的应用。在我对其进行了解的时候，发现有几种不同的工厂模式，本文对这几种工厂模式之间的差别进行一下分析和解读。<span id="more"></span></p><p>工厂模式的产生，是为了降低代码耦合，统一管理产品，提高工作效率。</p><h3 id="四种常见的工厂模式"><a href="#四种常见的工厂模式" class="headerlink" title="四种常见的工厂模式"></a>四种常见的工厂模式</h3><ol><li>StaticFactory Method - 静态工厂方法</li><li>SimpleFactory - 简单工厂</li><li>Factory Method - 工厂方法</li><li>Abstract Factory - 抽象工厂模式</li></ol><h4 id="StaticFactory-Method"><a href="#StaticFactory-Method" class="headerlink" title="StaticFactory Method"></a>StaticFactory Method</h4><p>相对于构造器来说，静态工厂有如下优势：</p><ul><li>方法名称不是固定的，可以自定义有意义的方法名称</li><li>返回值可以是原类型、子类型或是原始类型</li><li>可以控制类的实例，单例模式就是一种很好的应用</li></ul><p>静态工厂在jdk中也有使用，例如String、Integer、Long、Optional、Collections等包含的一系列静态工厂方法：</p><ul><li>String.valueOf(1000L);</li><li>Integer.valueOf(“180”);</li><li>Long.valueOf(“9999”);</li><li>Optional.of(“value”);</li><li>Collections.synchronizedCollection(originalCollection);</li></ul><h4 id="Simple-Factory"><a href="#Simple-Factory" class="headerlink" title="Simple Factory"></a>Simple Factory</h4><p>简单工厂模式，有一个专门的工厂类，可以根据参数去生产特定的产品，它不属于23GOF。例如下面的一个电脑工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static final int HP = 1;</span><br><span class="line">    public static final int LENOVO = 2;</span><br><span class="line">    public static final int APPLE = 3;</span><br><span class="line"></span><br><span class="line">    public static Computer createComputer(int param) &#123;</span><br><span class="line">        switch (param) &#123;</span><br><span class="line">            case HP:</span><br><span class="line">                return new HpComputer();</span><br><span class="line">            case LENOVO:</span><br><span class="line">                return new LenovoComputer();</span><br><span class="line">            case APPLE:</span><br><span class="line">                return new AppleComputer();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h4><p>工厂模式有一个工厂父类，提供了生产电脑的接口，各个厂牌的工厂可以去继承并实现它，完成自己的生产逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 父类工厂</span><br><span class="line">public interface ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    Computer createComputer();</span><br><span class="line">&#125;</span><br><span class="line">// 惠普工厂实现</span><br><span class="line">public class HpComputerFactory implements ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Computer createComputer() &#123;</span><br><span class="line">        return new HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 联想工厂实现</span><br><span class="line">public class LenovoComputerFactory implements ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Computer createComputer() &#123;</span><br><span class="line">        return new LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h4><p>到了抽象工厂，就要提到产品簇（Product Family）的概念。产品簇指的是具有相似功能的一系列产品，它们通常需要聚合或是搭配着来完成一项功能。例如上面的电脑产品，其可以被拆分为主机、屏幕、键盘、鼠标、耳机等等。这些拆分的部件通常也不是在一个工厂完成生产，而且也不一定都和自己的厂牌结合使用。厂牌下的各个子产品的生产逻辑抽象出来产生了抽象工厂这种设计方法。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 父类产品工厂</span><br><span class="line">public interface ComputerProductFactory &#123;</span><br><span class="line"></span><br><span class="line">    Keyboard createKeyboard();</span><br><span class="line"></span><br><span class="line">    Mouse createMouse();</span><br><span class="line"></span><br><span class="line">    Earphone createEarphone();</span><br><span class="line">&#125;</span><br><span class="line">// 惠普产品工厂实现</span><br><span class="line">public class HpProductFactory implements ComputerProductFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Keyboard createKeyboard() &#123;</span><br><span class="line">        return new HpKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mouse createMouse() &#123;</span><br><span class="line">        return new HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Earphone createEarphone() &#123;</span><br><span class="line">        return new HpEarphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 联想产品工厂实现</span><br><span class="line">public class LenovoProductFactory implements ComputerProductFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Keyboard createKeyboard() &#123;</span><br><span class="line">        return new LenovoKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mouse createMouse() &#123;</span><br><span class="line">        return new LenovoMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Earphone createEarphone() &#123;</span><br><span class="line">        return new LenovoEarphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>产品簇指具有相同或相似的功能结构或性能，共享主要的产品特征、组件或子结构，并通过变型配置来满足特定市场的一组产品的聚类。其背景是一个规划精良的结构，即可以用来生成产品族的产品族概念结构和总体逻辑结构，有助于把握和利用产品的共性。每一个新产品都是该结构的具体实例，也是对结构的扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工厂设计模式是众多设计模式当中我最早接触的设计模式，也是一种应用最为广泛的设计模式，属于创建型设计模式。在Spring框架中，也有很经典的应用。在我对其进行了解的时候，发现有几种不同的工厂模式，本文对这几种工厂模式之间的差别进行一下分析和解读。</summary>
    
    
    
    
    <category term="设计模式" scheme="https://kevll.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程语言的各种“类别”</title>
    <link href="https://kevll.com/2019/04/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%90%84%E7%A7%8D%E2%80%9C%E7%B1%BB%E5%88%AB%E2%80%9D/"/>
    <id>https://kevll.com/2019/04/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%90%84%E7%A7%8D%E2%80%9C%E7%B1%BB%E5%88%AB%E2%80%9D/</id>
    <published>2019-04-08T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.172Z</updated>
    
    <content type="html"><![CDATA[<p>目前的工作中，已经学习到了三种语言，Java，JS，Python。在说到这些语言时，经常会听到别人对它们的不同称呼，例如说Java是静态语言；Python、JS是脚本语言；Java是强类型而Python、JS是弱类型；Python、JS是解释型语言等。很好奇这些分类到底是怎么划分的，在查阅相关资料后对这些语言类别做了一些整理和归纳。<span id="more"></span></p><p>其实看了一些文章后才知道，这些语言的类型划分并不存在一个严格的定义，大多都是众人口传口的一种说法。所以下文的分析也只能保持一定程度的参考性，只为了更好的理解语言之间的区别。</p><h2 id="编译型语言、解释型语言"><a href="#编译型语言、解释型语言" class="headerlink" title="编译型语言、解释型语言"></a>编译型语言、解释型语言</h2><p><strong>编译或解释不是语言的特性，而是实现的特性。</strong> 所以广义上的编译和解释的区分，在于语言偏向用哪一种方式实现。所以如果你写了一个C语言的解释器的话，也可以让C直接解释执行了。在R大的这篇<a href="https://rednaxelafx.iteye.com/blog/492667">文章</a>中可以看到编译与解释在一定程度上的区别：采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如基本块&#x2F;函数&#x2F;方法&#x2F;trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。</p><h2 id="静态语言、动态语言"><a href="#静态语言、动态语言" class="headerlink" title="静态语言、动态语言"></a>静态语言、动态语言</h2><p>动态语言在运行时进行类型检查，在编写代码的时候可以不指定变量的数据类型，比如Python、JS。而静态语言例如C、Java，它们的数据类型是在编译期确定的，所在声明变量的同时要显式地写清数据类型，这样的好处是可以提前检查出程序中可能出现的类型错误。</p><h2 id="强类型、弱类型"><a href="#强类型、弱类型" class="headerlink" title="强类型、弱类型"></a>强类型、弱类型</h2><p>强弱类型指的是语言的类型系统对类型检查的严格程度。弱类型允许变量类型的隐式转化，而强类型一般不允许这样做。其实这也是和语言的主流编译器有关系的，Python被称为强类型，因为CPython在运行期检测到类型错误时，程序会中断执行。</p><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>脚本语言也是一个常常听到的名词。它给我的感觉就是方便快捷，不一定像一门编程语言一样有复杂的设计、严谨的语法和规则。例如我们在Linux中为了自动化部署程序写的shell脚本，在windows里执行批任务的vbs脚本。脚本语言是最松散的类型定义，完全没有类型声明，并且在运行时进行动态类型检查。脚本语言可以是交互式的，这样完全将编译过程从编辑-编译-运行循环中去掉了。脚本语言在易用性的优势让它的执行速度比系统语言慢了很多。它的代码可以以源代码的方式发布执行，虽然Python也有编译的步骤，但大多数情况直接接受源代码，而不是编译后的文件。</p><p>参考：<br><a href="https://www.zhihu.com/question/19918532">知乎-弱类型、强类型、动态类型、静态类型语言的区别是什么？</a><br><a href="https://rednaxelafx.iteye.com/blog/492667">RednaxelaFX-虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a><br><a href="https://www.zhihu.com/question/19608553">知乎-Java 是编译型语言还是解释型语言？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前的工作中，已经学习到了三种语言，Java，JS，Python。在说到这些语言时，经常会听到别人对它们的不同称呼，例如说Java是静态语言；Python、JS是脚本语言；Java是强类型而Python、JS是弱类型；Python、JS是解释型语言等。很好奇这些分类到底是怎么划分的，在查阅相关资料后对这些语言类别做了一些整理和归纳。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java发展简史</title>
    <link href="https://kevll.com/2019/02/15/Java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/"/>
    <id>https://kevll.com/2019/02/15/Java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.163Z</updated>
    
    <content type="html"><![CDATA[<p>作为个人专业和目前工作使用最多的语言，Java对我的影响很大。目前Java 11都已经发布了，然而大部分公司还是在使用Java 8及以下的版本。不经感叹Java发展之迅速，编码行业的技术日新月异，不知道会不会哪一天也学不动了。在不断发展的同时也要去了解它的历史与发展历程，这样才会对一个事物有更好的理解。以下是我个人收集和整理的一段简易Java发展史。<span id="more"></span></p><p>在20世纪90年代，单片式计算机系统出现，其价格低廉。Sun公司为了抢占市场，在1991年成立了名为Green的开发小组，专门研究在家电产品上的嵌入式应用，当时的开发人员有：帕特里克·诺顿(Patrick Naughton)、詹姆斯·高斯林(James Gosling)、麦克·舍林丹(Mike Sheridan)。</p><p>他们首先考虑使用C++来编写程序，但是由于单片机系统的硬件资源匮乏，C++过于复杂与庞大，电子产品的嵌入式处理器芯片种类繁杂，如何让软件跨平台运行也是难题。因此他们决定编写一款新的语言，他们结合单片机系统的要求对C++进行了改造，放弃了C++中的多继承和指针等概念，实现了一套自己的内存管理机制，变得更简单易用。他们假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后，能有半导体芯片生产商开发和生产这种硬件平台。</p><p>这个新的语言一开始是以高斯林办公室外的一棵橡树命名为Oak，在注册商标时发现已被抢注，后来更名Green，最后确定为Java，源自于Green小组人员喝的以印尼爪哇(Java)岛出产的咖啡。</p><p>一开始的时候Green更本没有想到Oak会与电脑、互联网产生联系，它只是一个用来解决诸如电视机、电话、面包机等家用电器的控制和通讯问题。然而Oak后期并没有得到硬件厂商的支持，而被搁置。1994年的时候团队决定改变方向，将技术应用于万维网，由此产生了Applet。Applet是一种将小程序嵌入到网页中进行执行的技术），并将Oak正式更名为Java。</p><p>1995年5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。</p><p>1997年11月17日，国际标准化组织（ISO）同意采纳Sun公司的专利技术——Java作为ISO标准。JAVA作为一个技术标准供公众无偿使用。根据ISO的批准，Sun公司将可提交JAVA的标准化平台规范。</p><p>2009年，甲骨文公司宣布收购Sun。2010年，Java编程语言的共同创始人之一詹姆斯·高斯林从Oracle公司辞职。2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。2014年，甲骨文公司发布了Java8正式版。</p><p>直至目前的Java版本历代更新，以及部分更新内容如下所示：</p><h4 id="JDK-1-0-January-23-1996"><a href="#JDK-1-0-January-23-1996" class="headerlink" title="JDK 1.0 (January 23, 1996)"></a>JDK 1.0 (January 23, 1996)</h4><ul><li>Java第一个正式版本JDK1.0.2发布</li></ul><h4 id="JDK-1-1-February-19-1997"><a href="#JDK-1-1-February-19-1997" class="headerlink" title="JDK 1.1 (February 19, 1997)"></a>JDK 1.1 (February 19, 1997)</h4><ul><li>引入JavaBeans</li><li>引入JDBC</li><li>引入RMI</li></ul><h4 id="J2SE-1-2-December-8-1998-Palyground-操场"><a href="#J2SE-1-2-December-8-1998-Palyground-操场" class="headerlink" title="J2SE 1.2 (December 8, 1998) (Palyground, 操场)"></a>J2SE 1.2 (December 8, 1998) (Palyground, 操场)</h4><ul><li>引入Swing API</li><li>Sun的JVM第一次引入JIT即时编译器</li><li>版本名改为J2SE，为了与J2EE和J2ME区分开来。这是一个很重要的版本更新，59个package中的class增加了3倍到1520个</li></ul><h4 id="J2SE-1-3-May-8-2000-Kestrel-红隼"><a href="#J2SE-1-3-May-8-2000-Kestrel-红隼" class="headerlink" title="J2SE 1.3 (May 8, 2000) (Kestrel, 红隼)"></a>J2SE 1.3 (May 8, 2000) (Kestrel, 红隼)</h4><ul><li>引入HotSpot JVM</li><li>引入JavaSound（不知道是啥）</li></ul><h4 id="J2SE-1-4-February-6-2002-Merlin-隼"><a href="#J2SE-1-4-February-6-2002-Merlin-隼" class="headerlink" title="J2SE 1.4 (February 6, 2002) (Merlin, 隼)"></a>J2SE 1.4 (February 6, 2002) (Merlin, 隼)</h4><ul><li>引入断言</li><li>引入正则表达式</li><li>支持IPv6</li><li>引入NIO</li><li>引入XML处理</li><li>引入Image I&#x2F;O API</li></ul><h4 id="J2SE-5-0-September-30-2004-Tiger-老虎"><a href="#J2SE-5-0-September-30-2004-Tiger-老虎" class="headerlink" title="J2SE 5.0 (September 30, 2004) (Tiger, 老虎)"></a>J2SE 5.0 (September 30, 2004) (Tiger, 老虎)</h4><ul><li>引入泛型</li><li>引入元数据，也称之为注解</li><li>自动拆装箱</li><li>可变参数 (String… args)</li><li>增强的循环 for each</li><li>引入Lock，代码级的锁</li><li>版本代号由原本的1.5改为5.0</li><li>加入Concurrent包</li></ul><h4 id="Java-SE-6-December-11-2006-Mustang-野马"><a href="#Java-SE-6-December-11-2006-Mustang-野马" class="headerlink" title="Java SE 6 (December 11, 2006) (Mustang, 野马)"></a>Java SE 6 (December 11, 2006) (Mustang, 野马)</h4><ul><li>JDBC 4.0</li><li>支持脚本语言</li><li>GUI的升级与优化</li></ul><h4 id="Java-SE-7-July-28-2011-Dolphin-海豚"><a href="#Java-SE-7-July-28-2011-Dolphin-海豚" class="headerlink" title="Java SE 7 (July 28, 2011) (Dolphin, 海豚)"></a>Java SE 7 (July 28, 2011) (Dolphin, 海豚)</h4><ul><li>JVM支持动态语言</li><li>swith支持String作为参数</li><li>一个语句块可以捕获多种异常</li><li>NIO 2.0</li></ul><h4 id="Java-SE-8-March-18-2014"><a href="#Java-SE-8-March-18-2014" class="headerlink" title="Java SE 8 (March 18, 2014)"></a>Java SE 8 (March 18, 2014)</h4><ul><li>引入Lambda表达式</li><li>引入管道和流</li><li>引入新的日期和时间的API</li><li>接口允许有默认实现</li><li>引入函数式接口</li></ul><h4 id="Java-SE-9-September-21-2017"><a href="#Java-SE-9-September-21-2017" class="headerlink" title="Java SE 9 (September 21, 2017)"></a>Java SE 9 (September 21, 2017)</h4><ul><li>模块化</li><li>集合工厂方法</li><li>私有接口方法</li><li>JShell交互式编程环境</li></ul><h4 id="Java-SE-10-March-20-2018"><a href="#Java-SE-10-March-20-2018" class="headerlink" title="Java SE 10 (March 20, 2018)"></a>Java SE 10 (March 20, 2018)</h4><ul><li>局部变量类型推断 var</li><li>GC改进和内存管理</li></ul><h4 id="Java-SE-11-September-25-2018"><a href="#Java-SE-11-September-25-2018" class="headerlink" title="Java SE 11 (September 25, 2018)"></a>Java SE 11 (September 25, 2018)</h4><ul><li>引入ZGC</li><li>安全类库、标准等方面的大范围升级</li></ul><p>高司令很喜欢说的一个故事是：你知道巴西的税务系统，亚马逊的Kindle阅读器以及韩国的第一大镁板制造厂有什么共同点吗?这些系统同世界上其它100亿个设备共享一个元素，那就是Java。</p><p>参考：<br><a href="https://en.wikipedia.org/wiki/Java_(programming_language)">维基百科-Java(programming language)</a><br><a href="https://baike.baidu.com/item/Java/85979?fr=aladdin">百度百科-Java(计算机编程语言)</a><br><a href="https://en.wikipedia.org/wiki/Java_version_history">维基百科-Java version history</a><br><a href="http://oracle.com.edgesuite.net/timeline/java/">Java Timeline</a></p><p>last update: 2019-10-01</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为个人专业和目前工作使用最多的语言，Java对我的影响很大。目前Java 11都已经发布了，然而大部分公司还是在使用Java 8及以下的版本。不经感叹Java发展之迅速，编码行业的技术日新月异，不知道会不会哪一天也学不动了。在不断发展的同时也要去了解它的历史与发展历程，这样才会对一个事物有更好的理解。以下是我个人收集和整理的一段简易Java发展史。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于synchronized的那些事</title>
    <link href="https://kevll.com/2018/11/05/%E5%85%B3%E4%BA%8Esynchronized%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://kevll.com/2018/11/05/%E5%85%B3%E4%BA%8Esynchronized%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.164Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized是Java中用来处理多线程的字段，也是我刚开始接触多线程时碰到的字眼，此篇记录下关于synchronized的一些理解和学习记录。<span id="more"></span></p><h3 id="synchronized是什么？"><a href="#synchronized是什么？" class="headerlink" title="synchronized是什么？"></a>synchronized是什么？</h3><p>synchronized是Java语法中的一个关键字，它可以作用在方法体和代码块上。这个关键字在被编译之后，会形成monitorenter和monitorexit两个字节码指令。这两个指令表示同步块的进入和退出，执行monitorenter时，线程尝试去获取锁的对象，如果获取成功，锁计数+1；执行到monitorexit时，锁计数-1，锁被释放。另一种说法就是sychronized就是JVM的这两个字节码指令暴露给程序员使用的接口。</p><h3 id="synchronized修饰方法与代码块的区别"><a href="#synchronized修饰方法与代码块的区别" class="headerlink" title="synchronized修饰方法与代码块的区别"></a>synchronized修饰方法与代码块的区别</h3><p>synchronized在修饰代码块时，会传递一个锁参数，如果这个参数是this的话，那同步代码块和同步方法也没什么区别。这种也叫做静态同步，它锁定的是类。另一种为非静态同步，锁定的是类的实例。在以实例为锁的情况下，在使用同一实例的时候就只能有一个线程可以进入同步块。</p><h3 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h3><ol><li>Lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现，Lock底层由volatile和CAS实现</li><li>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。） </li><li>Lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断； </li><li>Lock可以通过trylock来知道有没有获取锁，而synchronized不能； </li><li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;synchronized是Java中用来处理多线程的字段，也是我刚开始接触多线程时碰到的字眼，此篇记录下关于synchronized的一些理解和学习记录。</summary>
    
    
    
    
    <category term="并发" scheme="https://kevll.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>理解数据库事务</title>
    <link href="https://kevll.com/2018/10/20/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://kevll.com/2018/10/20/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.171Z</updated>
    
    <content type="html"><![CDATA[<p>事务是数据库提供的一种功能，为了保证数据操作的安全性。在数据库中，一个事务可以是一条语句，也可以是多条语句的联合。事务应该具有4个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为ACID特性。<span id="more"></span></p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ol><li>读未提交 Read Uncommitted：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交 Read Committed：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读 Repeatable Read： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化 Serializable：所有事物串行处理（牺牲了效率）</li></ol><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了幻读：（针对其他提交前后，读取数据条数的对比） </p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。幻读的重点在于新增或者删除 (数据条数变化)同样的条件, 第1次和第2次读出来的记录数不一样事务的传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ol><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;事务是数据库提供的一种功能，为了保证数据操作的安全性。在数据库中，一个事务可以是一条语句，也可以是多条语句的联合。事务应该具有4个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为ACID特性。</summary>
    
    
    
    
    <category term="数据库" scheme="https://kevll.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>线程安全的级别与实现</title>
    <link href="https://kevll.com/2018/07/18/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://kevll.com/2018/07/18/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.172Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的理解中，以为一个类要么是线程安全的，要么是不安全的，但其实这里面还有细分和区别。此篇讨论一下多线程的不同安全级别，以及操作系统和程序是如何来实现线程安全的。<span id="more"></span></p><h2 id="安全级别"><a href="#安全级别" class="headerlink" title="安全级别"></a>安全级别</h2><p>在《深入JVM》一书中，按照线程安全的“安全程度”由强到弱可以分为以下5个级别：</p><ol><li><p>不可变<br>在Java中，不可变的对象一定是线程安全的，在使用的时候不需要任何额外的手段来保证线程安全。如果是基本数据类型，那么在定义的时候加上final关键字就可以保证它是不可变的，如果是对象，那么要保证对象的行为不会对自身的状态产生影响。例如String就是一个典型的不可变对象，它所有的操作方法都是返回一个新的对象而不改变原来的值。因为String是不可变的，所以在常量池里的字符串对象可以被所有的线程共享而不存在安全性的问题。</p></li><li><p>绝对线程安全<br>“绝对”的线程安全其实是一种很严格的定义，我们平时常说的线程安全大多都不是绝对的线程安全。如果一个类要达到绝对线程安全，那么就是说不管在什么情况下，都不需要额外的手段来保障线程安全。来看一个例子，一个线程安全的类在多线程下的操作依然产生异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class VectorTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Vector不是绝对的线程安全</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private static Vector&lt;Integer&gt; vector=new Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread=new Thread()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread printThread=new Thread()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            while(Thread.activeCount()&gt;20);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子会抛出以下异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-1497&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 26</span><br><span class="line">at java.util.Vector.get(Vector.java:748)</span><br><span class="line">at com.kevll.temp.VectorTest$2.run(VectorTest.java:36)</span><br></pre></td></tr></table></figure><p>我们都知道Vector的add()，remove()，get()方法都是被synchronize修饰的，但是这样并不能保证在任何情况下调用它们都是线程安全的。确实如果单独调用remove()或是单独get()是不会报错的，但是同时使用的时候我们必须手动在程序中为这两个方法加上互斥，这样才能保证线程安全。此时，因为有了额外手段地加入，所以它并不是绝对地线程安全了。</p></li><li><p>相对线程安全<br>相对线程安全就是我们通常说的线程安全，它保证了对象地单独操作是安全的，Java中声明线程安全的类都是相对线程安全的，例如Vector和HashTable等。</p></li><li><p>线程兼容<br>线程兼容指的是对象本身不是线程安全的，但是可以通过额外的手段达到线程安全，Java中的大多数类都属于这种。</p></li><li><p>线程对立<br>线程对立是无论采用什么措施都不能在多线程下保证安全使用的代码。</p></li></ol><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>实现“线程”主要有3种方式：</p><ol><li><p>使用内核线程实现<br>内核线程是直接由操作系统支持和进行调度和切换的线程，但是程序一般使用的是内核线程的另一种接口：轻量级进程（Light Weight Process, LWP），就是我们通常说的线程，系统只有支持了内核线程才有轻量级进程。但是轻量级进程还是基于内核线程实现的，每次线程的操作都会消耗一定的内核资源，系统级的调用代价相对较高，需要在用户态和内核态之间来回切换。而且一个系统支持的轻量级进程的数量也是有限的。</p></li><li><p>使用用户线程实现<br>用户线程则是完全建立在用户空间的线程库上，线程的操作都在用户态中完成，不需要去调用内核。这种线程操作速度快、消耗低，所以支持更大规模的线程数量。但是此时线程的调度和切换的问题都要有用户程序来自己控制，复杂度较大，在处理多核间线程和阻塞的问题上就比较难以实现了。现在仅仅使用用户线程的程序越来越少，Java、Ruby等语言曾经使用过，后来抛弃了。</p></li><li><p>使用用户线程加轻量级进程混合实现<br>这种方式下，用户线程和轻量级进程同时存在，有了用户线程高效廉价和对大规模线程数量的支持，又可以通过轻量级进程与系统内核进行交互，是大多数程序采用的线程实现方式。</p></li></ol><p>Java线程的实现：<br>在jdk1.2之前，Java线程基于用户线程实现，之后采用基于操作系统原生线程模型来实现。</p><h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><p>实现线程安全主要有3种方式，其下有又有多种实现方式：</p><ol><li><p>互斥同步<br>保证共享数据在同一时刻只被一个线程使用。在Java中，提供了synchronized关键字可以实现互斥同步，它其实是monitorenter和monitorexit字节码指令对使用者开放的接口。synchronized是一种重量级的操作，前面说过Java线程是基于操作系统的原生线程，这是对线程的阻塞或唤醒操作都要在用户态和核心态之间切换。在jdk1.5的并发包之后，还可以使用ReentrantLock来实现同步，它是API层的互斥锁，而synchronized为原生语法层面的互斥锁。</p></li><li><p>非阻塞同步<br>上面的互斥同步也可称为阻塞同步，不管会不会发生冲突，直接对方法加锁，挂起线程以避免冲突。而非阻塞同步是不挂起线程，直接进行操作，遇到冲突再解决。这种同步需要保证操作和冲突检测这两个步骤的原子性，这有依赖于“硬件指令集的发展”。</p></li><li><p>无同步方案<br>我们要保证线程安全，才采用了同步这种手段，而如果一个方法不涉及数据共享或是代码本身就是线程安全的，则不需要采用同步，例如可重入代码和线程本地存储。</p></li></ol><ul><li><p>可重入代码：<br>这种代码有些相同的特性，它们不依赖存储在堆上的数据或是公用的系统资源，不调用非可重入的方法。也可以通过以下原则来判定：如果一个方法的结果可以预测，就是说每个给定参数都能返回相同的结果，那么它就是可重入的，是线程安全的。</p></li><li><p>线程本地存储：<br>如果共享数据的代码可以在同一线程内执行完的话，就可以将共享数据的可见范围控制在同一线程内，在Java中可以使用ThreadLocal实现线程本地存储的功能。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的理解中，以为一个类要么是线程安全的，要么是不安全的，但其实这里面还有细分和区别。此篇讨论一下多线程的不同安全级别，以及操作系统和程序是如何来实现线程安全的。</summary>
    
    
    
    
    <category term="并发" scheme="https://kevll.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>抓包分析TCP三次握手--简述四次挥手</title>
    <link href="https://kevll.com/2018/06/06/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B--%E7%AE%80%E8%BF%B0%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://kevll.com/2018/06/06/%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B--%E7%AE%80%E8%BF%B0%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>本篇记录一下利用wireshark抓tcp封包来分析tcp三次握手的过程，巩固一下网络基础知识。<span id="more"></span></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>因为http是基于tcp的，所以在这里我就直接打开浏览器进行网页请求，打开wireshark，写好filter条件，开始capture：</p><p>回忆一下tcp报文的header信息，红色框内信息为握手过程交互的关键字段。</p><p><img src="/180606_tcp_header.jpg" alt="TCP header(图片来源网络)"></p><p>接下来根据实际请求来详细分析一下，访问我的blog地址，解析出的ip是151.101.1.147，我的本机ip为192.168.1.94，下图最上面的三条即为三次握手协议。为简述将本地称为A，远端称为B。</p><p><img src="/180606_tcp_shake1.png" alt="第一次握手"><br>将SYN置1；发送A的序号0</p><p><img src="/180606_tcp_shake2.png" alt="第二次握手"><br>将SYN、ACK置1；发送ACK number&#x3D;A的序号+1&#x3D;0+1&#x3D;1；发送B的序号0</p><p><img src="/180606_tcp_shake3.png" alt="第三次握手"><br>将ACK置1；发送ACK number&#x3D;B的序号+1&#x3D;0+1&#x3D;1<br>至此，双方的TCP连接就建立起来了，可以开始传送数据了。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>建立连接需要三次握手，为什么断开连接还需要四次挥手呢？下面简述一下四次挥手的过程</p><ol><li><p>A发起中断连接请求，就是发送FIN报文。和上面的SYN、ACK一样，FIN为一个bit的状态码，FIN&#x3D;1表示要中断连接。</p></li><li><p>B收到A的中断请求后，要回复A一个ACK告诉自己已经收到中断请求的消息了。但是B可能还有向A传输的数据没有完成，socket不能马上关闭，所以只能让A等待。</p></li><li><p>B的数据传输完毕之后，告诉A可以关闭连接了，发送FIN&#x3D;1给A。</p></li><li><p>A收到B的关闭请求后，就知道可以关闭连接了。为了防止B不知道要关闭，所以还要发送一次ACK给B，之后自己进入等待，如果B没有收到ACK则可以重传。B收到ACK后，就可以断开连接了。如果A等待了一定时间后没有收到回复，表示B已正常关闭，则自己也关闭连接，这样就完成了连接断开的全部操作。</p></li></ol><blockquote><p>断开连接比建立连接多了一次的原因就是：在建立连接时B端的SYN和ACK是可以同时发送的，但是在断开的时候，FIN字段必须要等到B端传输完成后才能发送，并不能像SYN一样能同ACK一起发送给客户端，所以多了一次等待和发送，这样有了4次挥手的过程。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇记录一下利用wireshark抓tcp封包来分析tcp三次握手的过程，巩固一下网络基础知识。</summary>
    
    
    
    
    <category term="网络" scheme="https://kevll.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>从零开始写Spring</title>
    <link href="https://kevll.com/2018/05/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99Spring/"/>
    <id>https://kevll.com/2018/05/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99Spring/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2022-03-04T09:35:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>每一个使用Java开发的人对于Spring都再熟悉不过了，我也一直想了解它的工作机制。无奈源码不是那么容易直接阅读的，一个框架无疑是庞大和繁杂的，会有很多的细枝末节。为了避免掉进细节中出不来，只要把它的总体流程和机制理清就可以了。在搜索相关资料的时候发现了一个开源的<a href="https://github.com/code4craft/tiny-spring">Spring构建项目</a>，作者一步一步地实现了Spring的基础功能，这对于想学习Spring的人来说真是一份福音。我在这也只是模仿，试着创建一个基础的Spring框架，记下一些自己的总结。<span id="more"></span></p><p>在我初步的理解中，Spring是一个IOC的容器，我们只需要给出类的定义，实例化交由Spring来管理。因为在我们自己写程序的时候，想使用其它的类或是调用其它类的功能的时候，都是直接new，这样随意的实例化对象，在一个庞大的系统中肯定是一个不安全和不节省空间的方法。在这个开源项目中，作者使用tag标注了不同阶段的进度，可以依次构建出一个简单的Spring框架。</p><h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>创建BeanFactory就是要集中管理Bean，这里BeanFactory开放了两个接口，一个根据名称获得一个Bean的实例，还有一个就是向BeanFactory注册新的Bean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">Object getBean(String name);</span><br><span class="line"></span><br><span class="line">void registerBeanDefinition(String name, BeanDefinition beanDefinition) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的BeanDefinition就是对类信息进行管理的一个类，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition &#123;</span><br><span class="line"></span><br><span class="line">private Object bean; //bean的实例化对象</span><br><span class="line"></span><br><span class="line">private Class beanClass; //bean的类对象</span><br><span class="line"></span><br><span class="line">private String beanClassName; //类的全路径</span><br><span class="line"></span><br><span class="line">private PropertyValues propertyValues; //类的属性集合</span><br><span class="line"></span><br><span class="line">public BeanDefinition() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setBeanClassName(String beanClassName) &#123;</span><br><span class="line">this.beanClassName = beanClassName;</span><br><span class="line">try &#123;</span><br><span class="line">this.beanClass = Class.forName(beanClassName); //根据路径加载类，初始化类对象</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...setters and getters</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个定义类将一个类能用到的所有信息都集中在一起了，再以一个&lt;name,beanDefiniton&gt;键值的形式注册到BeanFactory当中，以后不管是谁要用什么类，都去BeanFactory里取。</p><p>这里有一个HelloSerive类，里面有一个类型为String的text属性，一个打印text内容的helloSpring方法，让我们看看BeanFactory是如何一步步管理和实例化这个类的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSerive &#123;</span><br><span class="line"></span><br><span class="line">private String text;</span><br><span class="line"></span><br><span class="line">public void helloSpring()&#123;</span><br><span class="line">System.out.println(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化BeanFactory，向BeanFactory注册HelloService，然后通过名称获取HelloService并调用方法打印text：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//AutowireCapableBeanFactory是BeanFactory的实现，是一个自动装载工厂</span><br><span class="line">BeanFactory beanFactory=new AutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">//register to beanFactory</span><br><span class="line">BeanDefinition beanDefinition=new BeanDefinition();</span><br><span class="line">beanDefinition.setBeanClassName(&quot;org.learn.test.HelloSerive&quot;);//将全路径告诉框架，由框架加载类</span><br><span class="line"></span><br><span class="line">//设置属性</span><br><span class="line">PropertyValues propertyValues = new PropertyValues();</span><br><span class="line">propertyValues.addPropertyValue(new PropertyValue(&quot;text&quot;, &quot;Hello Spring!&quot;));</span><br><span class="line">      beanDefinition.setPropertyValues(propertyValues);</span><br><span class="line"></span><br><span class="line">      //注册</span><br><span class="line">beanFactory.registerBeanDefinition(&quot;helloService&quot;,beanDefinition);</span><br><span class="line"></span><br><span class="line">//get bean and invoke helloSping method</span><br><span class="line">//获得bean都通过bean工厂</span><br><span class="line">HelloSerive helloSerive = (HelloSerive) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloSerive.helloSpring();</span><br></pre></td></tr></table></figure><p>之后就是对BeanFactory的实现，其中关键的几个部分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Map集合储存了所有Bean对象的信息，是一个大仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBeanInstatnce(BeanDefinition beanDefinition)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">return beanDefinition.getBeanClass().newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据类的路径去加载类，就获得了类的实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void setProperties(Object bean,BeanDefinition bd) throws Exception&#123;</span><br><span class="line">for (PropertyValue propertyValue : bd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">declaredField.setAccessible(true);</span><br><span class="line">declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射，将类的属性注入到实例当中，这里需要注意的是：declaredField.setAccessible(true);因为text属性被private修饰，要设置访问权限为true，不然无法注入属性值。</p><p>之后，通过BeanFactory的getBean方法获取HelloService的实例，然后调用HelloSpring方法，就可以把text打印出来了。</p><h1 id="bean的配置分离"><a href="#bean的配置分离" class="headerlink" title="bean的配置分离"></a>bean的配置分离</h1><p>在阶段1的时候，我们注册bean和注入属性还要手动在代码中操作，在后期我们要将这些工作自动化，就是要将配置分离出来，这里用xml来作配置文件，可以看到类的配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean name=&quot;helloWorldService&quot; class=&quot;com.kevll.HelloWorldService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这里就是我们熟悉的Spring-beans的配置了，我们习惯性的操作都是在xml中配置上bean的全路径和属性，让Spring自己去加载，然后从BeanFactory中getBean。这里基本就是读取和解析xml，用的是javax.xml.parsers和org.w3c.dom下的工具包，可以将xml文件解析成一个dom对象，然后对其中的每个节点进行操作、取值。这里就属于比较细节和繁琐的部分了，我们没必要去看Spring是怎么一步一步的解析xml文件，只需要知道最终xml中的属性都将被加载到bean的定义中就行了。以下是xml解析类的部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void doLoadBeanDefinitions(InputStream inputStream) throws Exception &#123;</span><br><span class="line">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">Document doc = docBuilder.parse(inputStream);//构建了xml对应的Document文件对象</span><br><span class="line">// 解析bean</span><br><span class="line">registerBeanDefinitions(doc);</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerBeanDefinitions(Document doc) &#123;</span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">parseBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void parseBeanDefinitions(Element root) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line">for (int i = 0; i &lt; nl.getLength(); i++) &#123;//遍历取节点信息</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">if (node instanceof Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line">processBeanDefinition(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml解析完成后将遍历注入到BeanFactory中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String,BeanDefinition&gt; registry;//xml解析类中保存解析结果</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">//遍历注册到beanFactory中</span><br><span class="line">beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们可以将bean的配置与代码分离开了，实现了解耦，以后不管用哪个类，需要如何初始化这个类，都在xml中配置。</p><h1 id="向bean中注入bean"><a href="#向bean中注入bean" class="headerlink" title="向bean中注入bean"></a>向bean中注入bean</h1><p>之前的属性注入只是简单的基本类型，那如果属性是一个对象呢，一个用户自定义的对象。那我们就要根据这个bean的名称去BeanFactory找对应的对象，并对其进行初始化。属性包含引用的xml配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;outputService&quot; class=&quot;com.kevll.OutputService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;helloWorldService&quot; ref=&quot;helloWorldService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;helloWorldService&quot; class=&quot;com.kevll.HelloWorldService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;text&quot; value=&quot;Hello World!&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;outputService&quot; ref=&quot;outputService&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>可见helloWorldService的&lt;\property&gt;中使用了一个ref属性表示了引用，引用的是com.kevll.OutputService的bean name,这是在告诉解析器，我有一个com.kevll.OutputService类的属性。我们在这用一个BeanReference来表示这种引用关系，只要在xml中解析到ref，就为其加上一个属性值为BeanReference的PropertyValue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ref = propertyEle.getAttribute(&quot;ref&quot;);</span><br><span class="line">if (ref == null || ref.length() == 0) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span><br><span class="line">+ name + &quot;&#x27; must specify a ref or value&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BeanReference beanReference = new BeanReference(ref);</span><br><span class="line">beanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, beanReference));</span><br></pre></td></tr></table></figure><p>在我们注入属性时，如果检测到属性为一个引用，也要去BeanFactory中获得这个引用的实例，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object value = propertyValue.getValue();</span><br><span class="line">if (value instanceof BeanReference) &#123;</span><br><span class="line">BeanReference beanReference = (BeanReference) value;</span><br><span class="line">value = getBean(beanReference.getName());</span><br><span class="line">&#125;</span><br><span class="line">declaredField.set(bean, value);</span><br></pre></td></tr></table></figure><p>这里对BeanFactory还有一个优化，延后了bean的实例化，实现了懒加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws Exception&#123;</span><br><span class="line">BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">if (beanDefinition == null) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;No bean named &quot; + name + &quot; is defined&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Object bean = beanDefinition.getBean();</span><br><span class="line">if (bean == null) &#123;//如果BeanFacoty没有该类，再去加载</span><br><span class="line">bean = doCreateBean(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerBeanDefinition(String name, BeanDefinition beanDefinition) throws Exception&#123;</span><br><span class="line">//Object bean = doCreateBean(beanDefinition);此方法被延后，注册时并不实例化，为了实现懒加载</span><br><span class="line">//beanDefinition.setBean(bean);</span><br><span class="line">       beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">       beanDefinitionNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也保留了预加载的选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//预加载</span><br><span class="line">public void preInstantiateSingletons() throws Exception &#123;</span><br><span class="line">for (Iterator it = this.beanDefinitionNames.iterator(); it.hasNext();) &#123;</span><br><span class="line">String beanName = (String) it.next();</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test中，读取xml配置并预加载类，调用helloWorld方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line">// 1.读取配置</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">// 2.初始化BeanFactory并注册bean</span><br><span class="line">AutowireCapableBeanFactory beanFactory = new AutowireCapableBeanFactory();</span><br><span class="line">for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beanFactory.preInstantiateSingletons();//预加载，关闭就是懒加载，在显示地getBean()时才去加载Bean</span><br><span class="line"></span><br><span class="line">// 3.获取bean</span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引入ApplicationContext"><a href="#引入ApplicationContext" class="headerlink" title="引入ApplicationContext"></a>引入ApplicationContext</h1><p>我们先来看一下引入ApplicationContext后的方法调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    HelloWorldService helloWorldService =(HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">    helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里应该就非常眼熟了，我们将读取xml配置和向BeanFactory中注册bean的操作再进一步的包装起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String configLocation) throws Exception &#123;</span><br><span class="line">this(configLocation, new AutowireCapableBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassPathXmlApplicationContext(String configLocation, AbstractBeanFactory beanFactory) throws Exception &#123;</span><br><span class="line">super(beanFactory);</span><br><span class="line">this.configLocation = configLocation;</span><br><span class="line">refresh();//默认为预加载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh() throws Exception &#123;</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line">for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们只需要告诉ApplicationContext配置文件xml的路径，所有的一切工作将由这个小Spring框架自动完成，我们只需要配置好xml，调用getBean，调用我们需要的方法就可以了。至此，Spring的IOC基本完成了，接下来的阶段就是AOP的实现了。</p><h1 id="引入Advice和Joinpoint"><a href="#引入Advice和Joinpoint" class="headerlink" title="引入Advice和Joinpoint"></a>引入Advice和Joinpoint</h1><p>这里使用的是AOP联盟提供的内容，现在pom中加入相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;aopalliance&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接下来要用到MethodInterceptor、MethodInvocation这两个接口，它们分别继承自Advice和Joinpoint。Advice作为增强，是在方法的周围增加自定义的操作。Joinpoint作为切入点，可以将新的行为从这些点插入到程序的正常的流程中。</p><h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>为了使用这两个功能，可以利用一个JDK提供的动态代理的功能，在反射包下有一个Proxy类，里有方法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] &#123; advised.getTargetSource()</span><br><span class="line">.getTargetClass() &#125;, this);</span><br></pre></td></tr></table></figure><p>此方法可通过代理类的类加载器、具体代理接口和InvocationHandler接口，创建一个代理类，InvocationHandler就是代理之后，在代理类调用方法时，实际拦截和调用的方法。InvocationHandler里是一个invoke方法，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123;</span><br><span class="line">MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span><br><span class="line">args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有我们自定义的一个MethodInterceptor，放在了advised中，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TimerInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        long time = System.nanoTime();</span><br><span class="line">        System.out.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; start!&quot;);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; end! takes &quot; + (System.nanoTime() - time)</span><br><span class="line">                + &quot; nanoseconds.&quot;);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invocation.proceed()是执行真实的方法，可以看到我们在真实方法调用的前后各打印了method start和method end两句话，完成了新行为的添加。<br>ReflectiveMethodInvocation是一个自定义的包装类，里面包含了代理类的实例和方法信息。它本身实现了MethodInvocation接口，向上就是Joinpoint接口，由它提供proceed()方法，其实就是method.invoke()调用。至此就可以基于JDK动态代理完成AOP功能了，完整JDK代理的调试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 设置被代理对象(Joinpoint)</span><br><span class="line">AdvisedSupport advisedSupport = new AdvisedSupport();</span><br><span class="line">TargetSource targetSource = new TargetSource(helloWorldService, HelloWorldService.class);</span><br><span class="line">advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">// 2. 设置拦截器(Advice)</span><br><span class="line">TimerInterceptor timerInterceptor = new TimerInterceptor();</span><br><span class="line">advisedSupport.setMethodInterceptor(timerInterceptor);</span><br><span class="line"></span><br><span class="line">// 3. 创建代理(Proxy)</span><br><span class="line">JdkDynamicAopProxy jdkDynamicAopProxy = new JdkDynamicAopProxy(advisedSupport);</span><br><span class="line">HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.getProxy();</span><br><span class="line"></span><br><span class="line">// 4. 基于AOP的调用</span><br><span class="line">helloWorldServiceProxy.helloWorld();</span><br></pre></td></tr></table></figure><h1 id="使用AspectJ管理切面"><a href="#使用AspectJ管理切面" class="headerlink" title="使用AspectJ管理切面"></a>使用AspectJ管理切面</h1><p>切面是通知和切点的结合，用来更方便的管理AOP的执行。AspectJ最早是一门语言，它的Poincut表达式被Spring借鉴了过来，因此我们可以实现一个AspectJExpressionPointcutAdvisor，利用表达式对需要代理的类进行筛选。我们可以用MethodMatcher测试一下方法和表达式是否匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMethodInterceptor() throws Exception &#123;</span><br><span class="line">    String expression = &quot;execution(* com.kevll.*.*(..))&quot;;</span><br><span class="line">    AspectJExpressionPointcut aspectJExpressionPointcut = new AspectJExpressionPointcut();</span><br><span class="line">    aspectJExpressionPointcut.setExpression(expression);</span><br><span class="line">    boolean matches = aspectJExpressionPointcut.getMethodMatcher().matches(HelloWorldServiceImpl.class.getDeclaredMethod(&quot;helloWorld&quot;),HelloWorldServiceImpl.class);</span><br><span class="line">    Assert.assertTrue(matches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将AOP植入Spring的Bean创建过程"><a href="#将AOP植入Spring的Bean创建过程" class="headerlink" title="将AOP植入Spring的Bean创建过程"></a>将AOP植入Spring的Bean创建过程</h1><p>我们不能每次使用AOP都来手动构建代理，最终还是要将一切过程自动化。在xml中配置Bean、配置Advice和表达式，让Spring帮我们完成筛选和代理的过程，所以我们要将AOP和代理植入Bean的创建过程。这里主要用到BeanPostProcessor接口，对Bean的创建进行无侵害式的植入。可以将通知和表达式的配置写在xml中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;aspectjAspect&quot; class=&quot;com.kevll.aop.AspectJExpressionPointcutAdvisor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;advice&quot; ref=&quot;timeInterceptor&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;expression&quot; value=&quot;execution(* com.kevll.*.he*(..))&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception;</span><br><span class="line"></span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是两个方法，分别在Bean初始化之前和之后进行操作，我们可以将这里的方法放在BeanFactory的getBean方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws Exception&#123;</span><br><span class="line">    BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">    if (beanDefinition == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No bean named &quot; + name + &quot; is defined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = beanDefinition.getBean();</span><br><span class="line">    if (bean == null) &#123;</span><br><span class="line">        bean = doCreateBean(beanDefinition);</span><br><span class="line">        bean = initializeBean(bean, name);//植入BeanProcessor</span><br><span class="line">        beanDefinition.setBean(bean);//用代理类代替原来的类</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的initializeBean就是执行postProcessAfterInitialization方法对Bean生成代理类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception &#123;</span><br><span class="line">    if (bean instanceof AspectJExpressionPointcutAdvisor) &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bean instanceof MethodInterceptor) &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory.getBeansForType(AspectJExpressionPointcutAdvisor.class);</span><br><span class="line">    for (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">        if (advisor.getPointcut().getClassFilter().matches(bean.getClass())) &#123;//匹配需要代理的类</span><br><span class="line">            AdvisedSupport advisedSupport = new AdvisedSupport();</span><br><span class="line">            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">            TargetSource targetSource = new TargetSource(bean, bean.getClass().getInterfaces());</span><br><span class="line">            advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">            return new JdkDynamicAopProxy(advisedSupport).getProxy();//返回JDK动态代理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在执行调用方法的时候拦截方法，匹配一下是否要对方法进行增强：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123;</span><br><span class="line">    MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">    //对切点的匹配</span><br><span class="line">    if (advised.getMethodMatcher() != null &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">        return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),</span><br><span class="line">                method, args));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，在xml配置过增强和切面后，再和平常一样调用helloWorld方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    HelloWorldService helloWorldService =(HelloWorldService) applicationContext.getBean(&quot;helloWorldService&quot;);</span><br><span class="line">    helloWorldService.helloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Invocation of Method helloWorld start!</span><br><span class="line">Hello World!</span><br><span class="line">Invocation of Method helloWorld end! takes 830130 nanoseconds.</span><br></pre></td></tr></table></figure><p>从而完成AOP的植入。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每一个使用Java开发的人对于Spring都再熟悉不过了，我也一直想了解它的工作机制。无奈源码不是那么容易直接阅读的，一个框架无疑是庞大和繁杂的，会有很多的细枝末节。为了避免掉进细节中出不来，只要把它的总体流程和机制理清就可以了。在搜索相关资料的时候发现了一个开源的&lt;a href=&quot;https://github.com/code4craft/tiny-spring&quot;&gt;Spring构建项目&lt;/a&gt;，作者一步一步地实现了Spring的基础功能，这对于想学习Spring的人来说真是一份福音。我在这也只是模仿，试着创建一个基础的Spring框架，记下一些自己的总结。</summary>
    
    
    
    
    <category term="源码" scheme="https://kevll.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK中的多线程</title>
    <link href="https://kevll.com/2018/04/18/JDK%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://kevll.com/2018/04/18/JDK%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.163Z</updated>
    
    <content type="html"><![CDATA[<p>开始在在多线程的坑中摸爬滚打。。<span id="more"></span></p><h2 id="让电脑做更多的事"><a href="#让电脑做更多的事" class="headerlink" title="让电脑做更多的事"></a>让电脑做更多的事</h2><p>Java学习到了后面，线程部分是相对来说难以理解和掌握的。初识线程时，知道它是电脑实现多任务的一种机制。然而在单核的CPU中并不是真正的同一时刻执行多个任务，而是不停地在线程间进行切换。好像多核的CPU可以真正的实现并发，但是自己还未涉及到。总的来说使用多线程可以让我们更好地利用系统资源去完成更多的事。</p><h2 id="开启一个线程"><a href="#开启一个线程" class="headerlink" title="开启一个线程"></a>开启一个线程</h2><p>Thread继承了一个接口Runnable，这个接口里只有一个方法run()，要让线程做的事也就写在run()里面。开启一个线程的方式为：new Thread(param).start()，param为实现了run()方法的Thread或Runnable对象。这时候线程就进入了就绪状态，等待CPU的调用了。</p><h2 id="同步与中断"><a href="#同步与中断" class="headerlink" title="同步与中断"></a>同步与中断</h2><p>多线程为我们带来高效的执行效果时，也同时增加了程序的复杂度，我们需要管理这些线程，并对程序中的数据进行安全化的处理。这时候线程间的同步和通信就显得尤为重要，Java里也提供了不同的机制让我们更好的使用多线程，有以下方法：<br>Object：</p><ul><li>wait()    线程等待，释放锁</li><li>notify()    线程唤起，释放锁</li></ul><p>Thread：</p><ul><li>sleep()    线程睡眠，不释放锁</li><li>interrupt()    通知线程中断</li></ul><p>Thread中还有方法：stop，suspend，resume，不过都不建议使用了，因为一个线程应该由自己来关闭。这里的interrupt()也不是真的中断了线程，而是将interrupt status设置为true，通知线程要停止操作了。线程需要自己扫描状态位，然后自己决定要做什么事，结束或是进行一些清理工作。</p><p>synchronized关键字；可以为代码块或是方法块加上同步锁，保证了操作的原子性。</p><h2 id="JDK5-之后的并发包"><a href="#JDK5-之后的并发包" class="headerlink" title="JDK5 之后的并发包"></a>JDK5 之后的并发包</h2><p>以上的都是传统多线程处理方法。jdk5之后增加了线程池、Callable和Future、锁对象Lock，可以让我们更轻松地去使用多线程来完成我们想要做的事。</p><h2 id="线程的三大特性"><a href="#线程的三大特性" class="headerlink" title="线程的三大特性"></a>线程的三大特性</h2><h3 id="原子性-可见性-有序性"><a href="#原子性-可见性-有序性" class="headerlink" title="原子性 可见性 有序性"></a>原子性 可见性 有序性</h3><p>这几个特性在线程的安全问题上必须要考虑周全了，缺一不可，不然就可能导致结果执行不正确。<br><strong>原子性</strong>：<br>即一个操作或者多个操作，为最小的不可分割的执行单位，执行的过程不会被任何因素打断。<br><strong>可见性</strong>：<br>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br><strong>有序性</strong>：<br>程序执行的顺序按照代码的先后顺序执行。一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><h2 id="JDK中的线程池"><a href="#JDK中的线程池" class="headerlink" title="JDK中的线程池"></a>JDK中的线程池</h2><p>jdk在5之后加入了concurrent包，提供了很多并发环境下实用的类，其中包括线程池ExecutorService。利用池化技术可以节省资源，提高性能，但是使用的不得当也会导致OOM，此篇说明线程池的核心参数和使用时的注意事项。<!--more--></p><h2 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h2><p>在使用线程池的过程中，很多人会使用Executors的静态方法去更便捷的创建一些线程池，主要有以下几种：</p><ul><li>newSingleThreadExecutor()</li><li>newFixedThreadPool(int nThreads)</li><li>newCachedThreadPool()</li><li>newScheduledThreadPool(int corePoolSize)</li></ul><p>阿里曾在他的开发手册中禁止开发人员使用Executors去创建线程池，而要使用ThreadPoolExecutor，为的应该是让开发人员多了解线程池的核心参数，避免使用不当。ThreadPoolExecutor也就是上面几个方法最后会调用的基础方法，其中的参数较多，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>corePoolSize 核心线程数，表示线程池中一般工作时保持的线程数量。注意线程池在创建的时候并不会启动核心线程，而是等到有任务提交时才去创建线程，除非主动调用prestartCoreThread或者prestartAllCoreThreads，所以在任务不充足的情况下线程池的大小也不一定是corePoolSize。</li><li>maximumPoolSize 线程池内的最大线程数量，表示线程池中允许存在的最大线程数量，包含核心线程和非核心线程。</li><li>keepAliveTime 多余闲置线程存活时间，“多余”指的是超过核心线程数量的非核心线程，当它们执行完任务后，超过存活时间就会被销毁。</li><li>unit 存活时间单位</li><li>workQueue 任务队列，暂存还没有被执行的任务，只会保存通过execute方法提交的任务。</li><li>threadFactory 线程工厂，创建线程时用的线程工厂，默认是Executors.defaultThreadFactory()。</li><li>handler 任务拒绝策略，当任务队列满了并且线程池内线程数达到最大时，对新加任务的处理策略。默认是AbortPolicy，即丢弃新加的任务并抛出异常RejectedExecutionException。</li></ol><h3 id="线程池的整个工作流程如下入所示"><a href="#线程池的整个工作流程如下入所示" class="headerlink" title="线程池的整个工作流程如下入所示"></a>线程池的整个工作流程如下入所示</h3><p><img src="/200130_threadpool.png" alt="线程池工作逻辑"></p><h2 id="使用Executors的利弊"><a href="#使用Executors的利弊" class="headerlink" title="使用Executors的利弊"></a>使用Executors的利弊</h2><p>好处当然是使用更加便捷，Executors不需要去管那么多的核心参数，能立马上手创建线程池用于任务执行。但是Executors里的一些静态方法创建的线程池，其线程池和任务队列的大小是没有限制的，有OOM的风险。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new LinkedBlockingQueue()的队列长度为Integer.MAX_VALUE(0x7fffffff)，基本是个无界队列，所以可以往队列中无限地添加任务，有可能发生OOM。</p><h3 id="newFixedThreadPool-int-nThreads"><a href="#newFixedThreadPool-int-nThreads" class="headerlink" title="newFixedThreadPool(int nThreads)"></a>newFixedThreadPool(int nThreads)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool与SingleThreadExecutor类似，区别就是核心线程数不同，使用的也是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                     60L, TimeUnit.SECONDS,</span><br><span class="line">                                     new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>核心线程数为0，最大线程数为Integer.MAX_VALUE，可以看作无限创建线程。而SynchronousQueue是一个不存储元素的队列，所以newCachedThreadPool每次将会创建非核心线程去执行任务。无限创建线程是一个很危险的动作，资源不足时会发生OOM。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始在在多线程的坑中摸爬滚打。。</summary>
    
    
    
    
    <category term="并发" scheme="https://kevll.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM内部原理[译]</title>
    <link href="https://kevll.com/2018/04/08/%E7%90%86%E8%A7%A3JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86[%E8%AF%91]/"/>
    <id>https://kevll.com/2018/04/08/%E7%90%86%E8%A7%A3JVM%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86[%E8%AF%91]/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.168Z</updated>
    
    <content type="html"><![CDATA[<p>看到一篇说JVM的外文写的不错，自己翻译一下。<span id="more"></span><br>原文链接：<a href="https://www.cubrid.org/blog/understanding-jvm-internals">https://www.cubrid.org/blog/understanding-jvm-internals</a><br>（文中图片均来自于原文）</p><p>每一个使用Java的开发者都知道Java字节码运行在JRE中（Java Runtime Environment）。JRE中最重要的元素就是Java虚拟机（JVM），由它解析和执行Java字节码。Java开发者不是必需要知道JVM是如何运行的。现在有许多开发出来的好的应用和库，而它们的开发者也没有对JVM有深入的理解。但是，如果你理解了JVM，你就会对Java有进一步的理解，也会有能力去解决那些看起来很简单却无法解决的问题了。<br>因此，在这篇文章中我将解释JVM是如何运行的，它的结构是怎样的，它怎样去执行Java字节码，执行的顺序，一些常见的错误和解决方法的案例，还有JavaSE7的新特性。</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><blockquote><p>JRE是由Java API和JVM组成的。JVM通过类加载器来读取Java应用然后结合Java API来执行它。</p></blockquote><p>一个虚拟机（VM）是一个机器（也就是电脑）的软件层实现，这个机器可以像物理真机一样执行程序。起初的时候，Java是基于要运行在一个从物理机分离出来的虚拟机而设计的，为了实现WORA（一次编写处处运行），虽然这个目标已经差不多被遗忘了。因此，JVM可以在各种硬件上执行Java字节码而不用更改Java代码。</p><h2 id="JVM的特性如下所示："><a href="#JVM的特性如下所示：" class="headerlink" title="JVM的特性如下所示："></a>JVM的特性如下所示：</h2><ul><li><strong>基于栈的虚拟机</strong>：许多流行的计算机架构例如Intel x86架构和ARM架构都是基于寄存器的（register），然而JVM是基于栈的。</li><li><strong>符号引用</strong>：所有的类型（类和接口），除了原始数据类型外都是通过符号引用的，而不是通过显示的基于内存地址的引用。</li><li><strong>垃圾回收</strong>：一个类的实例由用户显示地创建出来然后自动地被垃圾回收销毁。</li><li><strong>清晰地定义了原始数据类型来保证平台独立性</strong>：传统的语言，例如C或C++，它们int类型的数据在不同的平台有不同的大小。JVM清晰地定义了原始数据类型来保证了它的兼容性和平台间的独立性。</li><li><strong>网络字节序</strong>：Java的class文件使用了基于网络的字节序。为了在使用小端(little endian)的x86结构和使用大端(big endian)的RISC系列结构中保持良好的平台间独立性，必须要保持一个固定的字节码顺序。因此，JVM使用了网络字节序用来做网络传输。网络字节序是大端。</li></ul><p>Sun公司开发了Java，但是任何供应商可以自行开发和提供一个基于JVM标准的JVM。因此市场上有很多不同的JVM，包括Oracle的Hotspot和IBM JVM。Google的Android系统中的Dalvik也是一种JVM，尽管它没有完全遵循JVM的实现标准。和Java这种基于栈的机器不同的是，Dalvik是基于寄存器的结构。Java字节码也会转换成由Dalvik虚拟机使用的基于寄存器的指令集。</p><h3 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h3><p>为了实现一次编写处处运行，JVM使用了字节码，一种处于编程语言和机器语言间的中间语言。Java字节码是部署Java代码的最小单位。在详细地解释Java字节码之前，我们先简单地看一下。下面是来自开发过程中发生的一个真实实例的总结。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一个曾经成功运行的程序运行不起来了，而且在库更新过后，返回了以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.nhn.user.UserAdmin.addUser(Ljava/lang/String;)V</span><br><span class="line">    at com.nhn.service.UserService.add(UserService.java:14)</span><br><span class="line">    at com.nhn.service.UserService.main(UserService.java:19)</span><br></pre></td></tr></table></figure><p>程序的代码如下所示，没有被改动过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// UserService.java</span><br><span class="line">…</span><br><span class="line">public void add(String userName) &#123;</span><br><span class="line">    admin.addUser(userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级前后的库源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// UserAdmin.java - 更新后的代码</span><br><span class="line">…</span><br><span class="line">public User addUser(String userName) &#123;</span><br><span class="line">    User user = new User(userName);</span><br><span class="line">    User prevUser = userMap.put(userName, user);</span><br><span class="line">    return prevUser;</span><br><span class="line">&#125;</span><br><span class="line">// UserAdmin.java - 原始代码</span><br><span class="line">…</span><br><span class="line">public void addUser(String userName) &#123;</span><br><span class="line">    User user = new User(userName);</span><br><span class="line">    userMap.put(userName, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，没有返回值的addUser方法被改成了一个返回User类对象的方法。然而程序代码没有改变过，因为它并没有使用到addUser方法的返回值。</p><blockquote><p>第一眼看来，com.nhn.user.UserAdmin.addUser() 方法仍然存在，那为什么会发生NoSuchMethodError异常呢？</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>是因为程序代码没有被编译进新的库。换句话来说，程序代码看起来像是无视返回值调用了方法。但是，被编译过的类文件是明确知道这个方法的返回类型的。<br>你可以通过下列的错误信息看出这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.nhn.user.UserAdmin.addUser(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>NoSuchMethodError异常的发生是因为找不到”com.nhn.user.UserAdmin.addUser(Ljava&#x2F;lang&#x2F;String;)V”方法而引起的。注意看一下”Ljava&#x2F;lang&#x2F;String;”和最后的”V”。在Java字节码的表达中，”L<classname>;”表示类的实例。这表示addUser方法返回它需要一个java&#x2F;lang&#x2F;String类型的对象作为参数。在这个案例的库中，参数没有被改变，所以是正常的。异常信息最后一个”V”表示的就是方法的返回值。在Java字节码的表达中，”V”表示没有返回值。总结就是，异常信息表示一个需要java.lang.String为参数而返回值为com.nhn.user.UserAdmin.addUser的方法没有被找到。<br>因为程序代码被编译成之前库了，在这个类文件中定义的是要调用一个返回为”V”的方法。然而在改变过后的库中，返回”V”的方法已经不存在，而是加了一个返回”Lcom&#x2F;nhn&#x2F;user&#x2F;User;”的方法，所以发生了NoSuchMethodError的异常。</p><blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个错误的发生是因为开发者没有对更改后的代码进行重新编译。但是，在这个案例中，类库的提供者也要负大部分的责任。本来是一个公共的无返回值的方法，在之后被改成了返回User实例的方法。这明显是一个方法签名的更改。这意味着库的向后兼容已经被破坏了。所以，类库的的提供者必须要通知用户这个方法被改变了。</p></blockquote><p>让我们回到Java字节码，Java字节码是JVM的基本元素。JVM是一个执行Java字节码的执行器。Java编译器不会直接把一个高级语言，例如C&#x2F;C++，直接转换成机器语言（CPU指令）；它将开发者能够理解的Java代码转换成JVM能够理解的Java字节码。因为Java字节码是平台无关的，所以它在所有安装了JVM（准确来说是JRE环境）的硬件上都能被执行，即使当CPU或操作系统不同的时候也可以（一个在Windows上开发和编译过的类文件可以同样地在Linux的机器上运行，而且不用做任何的改变）。编译过后的文件大小基本与源代码的大小一致，使得通过网络来传输和执行Java字节码变得更简单。</p><p>class文件本身是一个二进制文件，人类不能直接进行阅读。为了管理class文件，JVM供应商提供了反编译器javap。使用javap得到的结果被称为Java编译指令。在上面的例子中，用javap -c option反编译程序代码中的UserService.add()方法得到的Java编译指令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)V</span><br><span class="line">   8:   return</span><br></pre></td></tr></table></figure><p>在这个java编译指令中，addUser()方法在第四行被调用：”5:invokevirtual;”。这表示对应到23索引位置的方法应该被调用。23索引位置的方法也被javap程序打上了注释。”invokevirtual”是在Java字节码中调用方法的最基本的操作码(Opcode, operation code)。另外，Java字节码中有四种操作码可以调用方法，它们是：invokeinterface, invokespecial, invokestatic 和invokevirtual。每一种操作码的含义如下所示：</p><ul><li>invokeinterface：调用一个接口的方法</li><li>invokespecial：调用一个初始化方法、私有方法或者父类中的方法</li><li>invokestatic：调用一个静态方法</li><li>invokevirtual：调用一个实例方法</li></ul><p>Java字节码的指令集包括操作码和操作数。像invokevirtual这样的操作码需要2个字节的操作数。</p><p>通过在类库更新之后编译上面的程序代码然后反编译的话，得到的结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return</span><br></pre></td></tr></table></figure><p>你可以看到对应到#23的方法已经改变为一个返回”Lcom&#x2F;nhn&#x2F;user&#x2F;User;”的方法了。</p><blockquote><p>在上面的反编译结果中，代码前面的数字是什么意思？</p></blockquote><p>它是字节数字。也许这就是为什么被JVM执行的代码要叫做“字节”码的原因。简单来说，这些字节码指令中的操作码，例如aload_0, getfield, 和invokevirtual都被表示为一个字节的字节数字。(aload_0&#x3D;0x2a, getfield&#x3D;0xb4, invokevirtual&#x3D;0xb6) 因此，Java字节码指令中最大的操作码数字为256。</p><p>像aload_0和aload_1这样的操作码不需要任何的操作数。因此aload_0的下一个字节就是下一个指令的操作码。然而像getfield和invokevirtual这样的操作码需要2个字节的操作数。因此，getfield的下一个指令的位置应该要跳过2个字节写在4字节的位置。通过16禁止编辑器查看到的字节码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a b4 00 0f 2b b6 00 17 57 b1</span><br></pre></td></tr></table></figure><p>在Java字节码中，类的实例被表示为“L;”，void被表示为“V”。类似的，其它的类型都有自己的表达方式。下面的表格总结了这些表示：<br>表1：Java字节码中的类型表示</p><table><thead><tr><th>Java字节码</th><th>类型</th><th>表示</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>单字节</td></tr><tr><td>C</td><td>char</td><td>Unicode字符</td></tr><tr><td>D</td><td>double</td><td>双精度浮点数</td></tr><tr><td>F</td><td>float</td><td>单精度浮点数</td></tr><tr><td>I</td><td>int</td><td>整型</td></tr><tr><td>J</td><td>long</td><td>长整型</td></tr><tr><td>L<classname></td><td>引用</td><td>classname类型的实例</td></tr><tr><td>S</td><td>short</td><td>短整型</td></tr><tr><td>Z</td><td>boolean</td><td>布尔类型</td></tr><tr><td>[</td><td>引用</td><td>一维数组</td></tr></tbody></table><p>下面的表格展示了一些字节码表示的例子：<br>表2：Java字节码表示的例子</p><table><thead><tr><th>Java代码</th><th>Java字节码表示</th></tr></thead><tbody><tr><td>double d[][][];</td><td>[[[D</td></tr><tr><td>Object mymethod(int i,double d,Thread t)</td><td>(IDLjava&#x2F;lang&#x2F;Thread;)Ljava&#x2F;lang&#x2F;Object;</td></tr></tbody></table><p>如果需要更多的细节，查看《Java虚拟机规范第二版》的4.3章描述符。在第6章可以查看各种Java字节码指令集的详细信息。</p><h2 id="类文件格式"><a href="#类文件格式" class="headerlink" title="类文件格式"></a>类文件格式</h2><p>在解释Java类文件格式之前，让我们来看一下一个在JavaWeb应用中经常发生的例子。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>编写了一个JSP然后在Tomcat上执行，JSP没有执行成功，发生了以下的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet.service() for servlet jsp threw exception org.apache.jasper.JasperException: Unable to compile class for JSP Generated servlet error:</span><br><span class="line">The code of method _jspService(HttpServletRequest, HttpServletResponse) is exceeding the 65535 bytes limit&quot;</span><br></pre></td></tr></table></figure><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>以上的错误信息在不同的Web应用容器中可能有稍微的不同，但是，有一点是相同的，那就是因为65536字节的限制。65536字节限制是一种JVM的限制，规定了一个方法最多不能超过65535个字节。<br>我将介绍这个65535字节限制，并且详细说明为什么要设立这个限制。<br>Java字节码中，表示分支和跳转的指令为“goto”和“jsr”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto [branchbyte1] [branchbyte2]</span><br><span class="line">jsr [branchbyte1] [branchbyte2]</span><br></pre></td></tr></table></figure><p>这两个指令都需要接受2个字节的有符号分支偏移量作为操作数，以至于让它们最大可以扩展到第65535个索引位。然而为了支持更大的分支范围，Java字节码还准备了“goto_w”和“jsr_w”，它们可以接受4个字节的有符号分支偏移量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto_w [branchbyte1] [branchbyte2] [branchbyte3] [branchbyte4]</span><br><span class="line">jsr_w [branchbyte1] [branchbyte2] [branchbyte3] [branchbyte4]</span><br></pre></td></tr></table></figure><p>使用这两个操作码的话，分支的范围就可以超过65535了。因此，Java方法65535字节的限制就可以被克服了。但是，因为其它的各种的Java类文件格式的限制，Java方法的大小还是不能超过65535个字节。我将简单地解释一下类文件格式来看看其它的一些限制。<br>Java类文件的大致结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_info constant_pool[constant_pool_count-1];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[fields_count];</span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];&#125;</span><br></pre></td></tr></table></figure><p>上面的结构来自《Java虚拟机规范第二版》的第4.1章“类文件结构”。</p><p>之前反编译过的UserService.class文件，用16进制编辑器可以看到文件前16字节如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca fe ba be 00 00 00 32 00 28 07 00 02 01 00 1b</span><br></pre></td></tr></table></figure><p>通过这些值，我们来看一下类文件的格式。</p><ul><li><strong>魔数：</strong> 类文件的前4个字节是一个魔数。这是一个用来区分Java类文件的预定义值。就像上面16进制编辑器显示的那样，这个值总是OxCAFEBABE。简单来说，当一个文件的开头前4个字节是0xCAFEBABE，这个文件就可以被看作一个Java类文件。”CAFEBABE”是一个有关”Java”这个名字的有趣的魔数。</li><li><strong>小版本，大版本：</strong> 接下来的4个字节表明了类的版本号。在UserService的类文件中的数值为0x00000032，类的版本号就是50.0。由JDK1.6编译的类文件的版本就是50.0，由JDK1.5编译的类文件的版本号就是49.0。JVM必须保持对比自己版本小的类文件的向后兼容性。另一方面来说，如果在一个低版本的JVM上执行高版本的类文件，就会发生java.lang.UnsupportedClassVersionError异常。</li><li><strong>常量池数，常量池：</strong> 在版本号之后就是类的常量池信息。这是在运行时常量池区域中的信息，将在之后解释。在加载类文件的时候，JVM把常量池的信息加载到了方法区中的运行常量池中。在UserService的类文件中constant_pool_count的值为0x0028，你可以看到常量池的索引有40-1&#x3D;39个。</li><li><strong>访问标识：</strong>:这是表示一个类的修饰符的符号位。它可以表示该类是否被public、final、abstract修饰，以及是否是一个interface。</li><li><strong>当前类，父类：</strong> 分别表示在常量池中的关于本类和父类的索引。</li><li><strong>接口数，接口：</strong> 表示了在常量池中的本类实现的接口数的索引，和每个接口的信息。</li><li><strong>变量数，变量：</strong> 类中变量的数量和变量的信息数组。变量的信息包括变量名、类型、修饰符，以及在常量池中的索引。</li><li><strong>方法数，方法：</strong> 一个类中的方法的数量和方法的信息数组。方法的信息包括了方法名、类型，和方法参数的数量、返回类型、修饰符，在常量池中的索引值，方法的可执行代码以及异常信息。</li><li><strong>属性数，属性：</strong> attribute_info有多种不同的属性。对于field_info或method_info，attribute_info就被使用了。</li></ul><p>javap反编译程序可简单地以一种用户可以读懂的方式展现出类文件的格式信息。当UserService.class使用“javap -verbose”解析过后，就展现以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;UserService.java&quot;</span><br><span class="line"> </span><br><span class="line">public class com.nhn.service.UserService extends java.lang.Object</span><br><span class="line">  SourceFile: &quot;UserService.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 50</span><br><span class="line">  Constant pool:const #1 = class        #2;     //  com/nhn/service/UserService</span><br><span class="line">const #2 = Asciz        com/nhn/service/UserService;</span><br><span class="line">const #3 = class        #4;     //  java/lang/Object</span><br><span class="line">const #4 = Asciz        java/lang/Object;</span><br><span class="line">const #5 = Asciz        admin;</span><br><span class="line">const #6 = Asciz        Lcom/nhn/user/UserAdmin;;// … omitted - constant pool continued …</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">// … omitted - method information …</span><br><span class="line"> </span><br><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   Stack=2, Locals=2, Args_size=2</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return  LineNumberTable:</span><br><span class="line">   line 14: 0</span><br><span class="line">   line 15: 9  LocalVariableTable:</span><br><span class="line">   Start  Length  Slot  Name   Signature</span><br><span class="line">   0      10      0    this       Lcom/nhn/service/UserService;</span><br><span class="line">   0      10      1    userName       Ljava/lang/String; // … Omitted - Other method information …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于篇幅限制，我从整体内容中提取了一部分。在全部的内容里还包括了其它各种关于常量池和每个方法的信息。<br>方法的65535字节大小限制与method_info的结构内容有关。method_info结构含有代码（Code），行号表（LineNumberTable），和本地变量表（LocalVariableTable）的属性，就像上面由“javap -verbose”命令展示出的一样。所有对应于行号表、本地变量表和代码中的异常表（exception_table）的长度的值都是固定的2个字节。因此，方法的长度不能超过行号表、本地变量表和异常表的长度，就被限制在了65535个字节。</p><p>许多的人抱怨方法大小的限制，JVM规范也声称将会在之后进行可扩充化，但是到目前为止还没有明确的进展。考虑到JVM规范的特性要将类文件中几乎所有的内容都加载到方法区，所以在扩展方法的大小同时要保证向后兼容性将是非常困难的。</p><blockquote><p>如果因为Java编译器的错误产生了一个错误的类文件会导致什么结果？或者，如果因为网络传输或者拷贝文件将一个类文件破坏了之后又会发生什么？</p></blockquote><p>为了应对这些情况，Java类加载器有一个非常严格的认证过程。JVM规范详细地描述了这个过程：</p><blockquote><p>注意</br><br>我们要如何证明JVM成功地执行了类文件认证的过程？我们如何证明不同的JVM厂商提供的不同的JVM平台是否满足了JVM规范？为此，Oracle提供了一个测试工具，TCK（Technology Compatibility Kit）。TCK通过执行数万个测试用例，包括在许多不同方式下产生错误类文件，来检验JVM的规范情况。通过了TCK的测试后，这个JVM才能被称为一个JVM。</p></blockquote><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p>使用Java所写的代码是由下图所示的流程执行的：<br><img src="/180408_execution_process.png" alt="图1：Java代码执行流程"><br>Java类加载器将编译过后的Java字节码文件加载到运行时数据区域中，执行引擎执行Java字节码。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了动态加载的特性，它将在运行时类第一次被引用时才去加载和链接这个类，而不是在编译期间加载。JVM的类加载器完成这个动态加载的过程。Java类加载器的特性如下所示：</p><ul><li><strong>层次结构：</strong>Java中的类加载器被组织为一种父子关系的层次型结构，Bootstrap类加载器是所有类加载器的父类。</li><li><strong>委派模式：</strong>基于层次结构，加载任务将在类加载器之间进行委派。当一个类被加载后，将由父类检查和确认是否这个类已经被父加载器加载过。如果父类加载器中有这个类，那么就使用这个类。如果没有，就用当前类加载器来加载这个类。</li><li><strong>可见限制：</strong>子类加载器可以从父类加载器中获取类，然而，父类加载器不能从子类加载器中获取类。</li><li><strong>卸载禁止：</strong>一个类加载器可以加载一个类但不能卸载它。然而可以删除当前的类加载器，创建一个新的类加载器。</li></ul><p>每一个类加载器都有它自己保存的已加载类的命名空间。当一个类加载器加载一个类时，它将基于FQCN（Fully Qualified Class Name, 全限定名）来在命名空间中检查这个类是否已经被加载。即使类之间有相同的全限定名但是命名空间不同，也将被认为是不同的类。不同的命名空间表示这个类被其它的类加载器加载过。<br>下面的图说明了类加载器的委派模式：<br><img src="/180408_delegation_model.png" alt="图2：类加载器的委派模式"><br>当一个类加载器被用来加载类的时候，它将按照从加载器缓存，父类加载器，和它自己的顺序中检查这个类是否已经存在。简单来说，加载器先从缓存中检查这个类是否已经被加载。如果没有加载，检查父类加载器有没有加载，如果检查到Bootstrap类加载器还是不存在这个类的话，那么当前的类加载器将在文件系统中寻找这个类并加载它。</p><ul><li><strong>Bootstrap类加载器：</strong>当JVM启动时，这个类加载器就会被创建。它将加载Java APIs，包括object类。和其它的类加载器不同的是，它是由本地（native）代码实现的，而不是Java。</li><li><strong>扩展类加载器：</strong>它将加载除了基本的Java APIs以外的扩展类，也会加载各种安全扩展功能。</li><li><strong>系统类加载器：</strong>如果说Bootstrap类加载器和扩展加载器是加载JVM组件的，那系统类加载器就是加载应用类。它将加载用户指定的$CLASSPATH里的类。</li><li><strong>用户自定义类加载器：</strong>这是一个用户在代码中直接创建的类加载器。</li></ul><p>像Web应用服务器（WAS:Web application server）这样的框架使用这样的自定义类加载器，使得Web应用与企业级应用可以相互独立运行。换句话说，通过类加载器的委派模式可以保证应用之间的独立性。这样的WAS类加载器结构都使用了层次结构，然而不同供应商提供的相应结构可能稍有不同。</p><p>如果类加载器发现了一个未加载的类，类将由如下所示的过程被装载和链接：<br><img src="/180408_class_load.png" alt="图3：类加载步骤"><br>每一个步骤描述如下：</p><ul><li><strong>加载：</strong>从文件中获取类加载到JVM内存中</li><li><strong>认证：</strong>验证加载的类是否符合Java语言和JVM的规范。这是类加载过程中最复杂、耗时最长的的一个测试步骤。JVM的TCK测试的大部分要在这测试在加载错误的类时能否得到相应的错误信息。</li><li><strong>准备：</strong>准备好数据结构，它指定了类所需要的内存空间，并且表明了类中的域、方法和接口。</li><li><strong>解析：</strong>将常量池中所有的对当前类的符号引用改为直接引用。</li><li><strong>初始化：</strong>将类的变量初始化为一个合理的值，执行静态初始化方法，初始化静态域的相应值。</li></ul><p>JVM规范定义了这些任务，但是也允许在执行的时候灵活处理。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/180408_runtime_data_areas.png" alt="图4：运行时数据区域配置"><br>运行时数据区域是JVM在系统上运行的时候被划分出的内存空间。运行时的数据区域可以划分成6个部分。它们是：为每个线程独立创建的PC寄存器、虚拟机栈和本地方法栈，以及所有线程间共享的堆、方法区和运行时常量池。</p><ul><li><p><strong>PC寄存器：</strong>每一个线程拥有一个PC（Program Counter）寄存器，当线程启动时被创建。PC寄存器存有当前将被执行的JVM指令的地址。</p></li><li><p><strong>虚拟机栈：</strong>每一个线程拥有一个虚拟机栈，也是当线程启动时被创建。这是一个保存了栈帧（Stack Frame）的栈结构。JVM会将栈帧压入或弹出虚拟机栈。如果发生了异常，类似printStackTrace()这样的方法，输出的栈追踪的每行信息就是一个栈帧信息。<br><img src="/180408_jvm_stack.png" alt="图5：虚拟机栈配置"></p></li><li><p>栈帧：当JVM中的一个方法被执行后，就会创建一个栈帧，这个栈帧将被加到当前线程的虚拟机栈中。当方法结束时，相应的栈帧也会被移除。每一个栈帧保存了到本地变量数组、操作数栈，和被执行方法所属类的运行时常量池的引用。本地变量数组和操作数栈的大小都在编译期被确定了。因此，一个方法相应的栈帧大小也是固定的。</p></li><li><p>本地变量数组：数组的索引由0开始。0位置存储着方法所属类的实例的引用。从1开始保存的是传递给方法的参数。在方法参数后面保存的就是方法的本地变量了。</p></li><li><p>操作数栈：是一个方法真正意义上的工作空间。每个方法交换操作数栈和本地变量数组中的数据，压入或弹出调用其它方法的结果值。操作数栈所必须的空间大小可以在编译的时候确定，因此，操作数栈的大小也可以在编译时确定。</p></li><li><p><strong>本地方法栈：</strong>一个本地的非Java的代码栈。换句话说，这是一个通过JNI(Javs Native Interface)来执行C&#x2F;C++代码的栈。根据语言的不同，将会创建一个C栈或C++栈。</p></li><li><p><strong>方法区：</strong>这是一个被所有线程共享的方法区，当JVM启动的时候被创建。它储存了运行时常量池、域和方法信息，静态变量，还有每个被JVM加载的类和接口的方法字节码。不同的JVM厂商实现方法区的格式都有不同。Oracle的Hotspot虚拟机称之为永久区（Permanent Area）或是永久代（Permanent Generation, PermGen）。垃圾收集是否对于方法区进行收集是可由JVM厂商选择的。</p></li><li><p><strong>运行时常量池：</strong>一个与类文件格式中的常量池表相对应的区域。这个区域被包含在方法区中，但是它在JVM的操作中扮演着重要的角色。因此，JVM规范还单独地描述它的重要性。除了每个类和接口的常量，它还包含了所有对方法和域的引用。简单来说，当一个方法或域被引用时，JVM将使用运行时常量池去查找方法或域在内存中的实际地址。</p></li><li><p><strong>堆：</strong>一个存放了实例或对象的空间，也是垃圾收集的目标区域。当讨论JVM性能的时候这个区域经常被提及。JVM厂商可以决定如何配置堆或是不执行垃圾收集。</p></li></ul><p>让我们回到我们之前讨论的反编译字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   getfield        #15; //Field admin:Lcom/nhn/user/UserAdmin;</span><br><span class="line">   4:   aload_1</span><br><span class="line">   5:   invokevirtual   #23; //Method com/nhn/user/UserAdmin.addUser:(Ljava/lang/String;)Lcom/nhn/user/User;</span><br><span class="line">   8:   pop</span><br><span class="line">   9:   return</span><br></pre></td></tr></table></figure><p>将反编译的代码与我们有时看见的x86架构的机器码进行比较，它们都有相似的格式，操作码，但是也有不同的地方：Java字节码不会写出寄存器的名称，内存地址或操作数的偏移位置。如之前描述的一样，JVM使用栈结构。因此，它不使用寄存器，与之不同的x86架构是使用寄存器的。它使用像15、23这样的索引而不是内存地址，是因为它自己管理内存。15、23这样的索引就是当前类（这里是UserService类）的常量池索引。简单来说，JVM为每一个类创建一个常量池，池中存放了对真实对象的引用。</p><p>反编译代码的每行解释如下：</p><ul><li>**aload_0:**将局部变量数组0索引处的元素加入操作数栈。局部变量表0索引处的元素总是this，代表了当前类的实例的引用。</li><li>**getfield #15:**在当前类的类常量池中，把索引为15的元素加入操作数栈。因为admin域是一个类实例，所以这里加入了一个引用。</li><li>**aload_1:**将局部变量数组1索引处的元素加入操作数栈。从局部变量表1索引开始存储的是方法的参数，所以当调用add()方法要传递的userName字符串的引用被加入到操作数栈。</li><li>**invokevirtual:**调用当前类常量池中#23处的方法。这时，使用getfield加入的引用和使用aload_1加入的参数被传递到调用的方法里。当方法调用结束后，返回值将被添加到操作数栈中。</li><li>**pop:**把调用invokevirtual方法的返回值从操作数栈弹出。你可以看到用之前的库编译的代码没有返回值。简单来说，之前的方法没有返回值，所以没有必要从栈中弹出返回值。</li><li>**return:**方法完成。</li></ul><p>下面的图将帮你理解上面的解析：<br><img src="/180408_bytecode_loaded.png" alt="图6：运行时数据区域加载Java字节码的例子"></p><p>为了示例，在这个方法中，本地变量数组没有被改变过。所以上图只展现了操作数栈的变化。但是，在大多的情况下，本地变量数组也会被改变。本地变量数组和操作数栈之间使用许多的加载指令（aload，iload）和存储指令（astore，istore）完成数据的传输。<br>在这个图中，我们看了一下运行时常量池和虚拟机栈的简短描述。当JVM启动时，每个类的实例将被分配到堆中，包含User，UserAdmin，UserService和String的类信息被存储到方法区中。</p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>通过类加载器被分配到JVM的运行时数据区域的字节码是通过执行引擎执行的。执行引擎以指令单元读入Java字节码。它就像CPU执行机器码一样一行一行依次执行。每一个字节码指令是由1个字节的操作码和附加的操作数组成的。执行引擎拿到一个操作码然后同操作数一起执行指令，然后执行下一个执行码。<br>但是Java字节码写成了人类可以理解的语言，而不是机器可以直接执行的语言。因此，执行引擎必须在JVM中将字节码转换为可以在机器上执行的语言指令。字节码有2种方式可以转换为合适的语言。</p><ul><li>解释器：读取，解释并逐行执行字节码指令。在它一行行地解释和执行指令地时候，它可以迅速解释一个字节码，但是解释结果的执行速度较慢。解释性语言都有这样的短处。字节码这样的语言基本上就像这样一个解释器一样运行。</li><li>即时编译器（JIT）：为了弥补解释器的这种短处，引入了JIT编译器。执行引擎先像一个解释器一样运行，然后在一个适当的时间，JIT编译器将整个字节码编译为本地代码。在那之后，执行引擎就不要再解释方法了，而是直接执行本地代码。本地代码的执行比一行行地解释指令要快得多。编译过的代码可以更快的执行，因为本地代码被储存在了缓存中。</li></ul><p>但是，JIT编译器编译代码比一行行地解释代码花费的时间要更多。因此，如果代码只被执行一次，那么解释比编译更好。因此，JVM在内部检查了方法被执行的频率，然后只在这个频率超过一个特定的水平的时候才进行即时编译。<br><img src="/180408_compiler_jit.png" alt="图7：Java编译器和即时编译器"></p><p>JVM规范并没有定义执行引擎如何运行。因此，虚拟机供应商使用各种不同的技术去提升他们的执行引擎，引入了各式不同的即时编译器。<br>大部分的即时编译器像下图一样运行：<br><img src="/180408_jit.png" alt="图8：即时编译器"></p><p>即时编译器将字节码转换成一种中间级的表达式，IR(Intermediate Representation)，优化之后，将这种表达式转换为本地代码。<br>Oracle Hotspot VM使用的是一种称为Hotspot编译器的即时编译器。它被称为Hotspot是因为Hotspot编译器搜索那些需要高优先级编译的“热点”代码，然后将这些“热点”编译为本地代码。如果一个方法含有编译过的字节码但是不再经常调用时，换句话来说就是这个方法不再是一个“热点”代码，Hotspot VM将移除缓存中的本地代码然后切换成解释器模式运行。Hotspot VM被分成Server VM和Client VM两种，这两种虚拟机使用不同的即时编译器。<br><img src="/180408_hotspot_client_server.png" alt="图9：Hotspot Client VM和Server VM"></p><p>Client VM和Server VM使用相同的运行时环境，但是他们使用不同的即时编译器，就像上图所示那样。Server VM使用的高级动态优化编译器使用了更为复杂和性能多样的优化技术。<br>IBM JVM从IBM JDK6引入了类似JIT编译器的AOT(Ahead Of Time)编译器。这意味着多个虚拟机之间可以通过共享缓存共享编译过后的本地代码。简单来说，已经通过AOT编译器编译过的代码可以被其它的JVM直接使用，不用再编译。另外，IBM JVM提供了一种快速执行代码的方法，通过使用AOT编译器将代码预编译成JXE(Java Executable)文件格式。</p><p>大部分的Java性能提升都是通过提升执行引擎实现的。像JIT编译器一样，各种优化技术被引入所以JVM的性能持续地提升。最初地JVM和最新地JVM之间的区别就是执行引擎的不同。</p><p>Hotspot编译器从Oracle Hotspot VM的1.3版本引入，JIT编译器从Android2.2开始引入Dalvik VM。</p><blockquote><p>注意<br>引入像字节码这样的中间语言的技术，用VM执行字节码，JIT编译器提升JVM的性能，在其它拥有中间语言的语言中这种方式也很常见。像Microsoft的.Net，他们的一种虚拟机称为CLR(Common Language Runtime)，执行一种称作CIL(Common Intermediate Language)的字节码。CLR提供像JIT编译器一样的AOT编译器。因此，用C#或VB.NET写的代码，经由编译器编译成CIL然后运行在有JIT编译器的CLR上。CLR也采用了垃圾处理机制，像JVM一样是基于栈的机器。</p></blockquote><h2 id="Java虚拟机规范，JavaSE第7版"><a href="#Java虚拟机规范，JavaSE第7版" class="headerlink" title="Java虚拟机规范，JavaSE第7版"></a>Java虚拟机规范，JavaSE第7版</h2><p>在2011年7月28号，Oracle发布了JavaSE第7版并将JVM规范也更新到了第7版。在1999年发布了《Java虚拟机规范第二版》后，Oracle花了12年才发布了更新版本。更新版本包含了许12年间积累的许多改变和修改，描述了一个更为清晰的规范文件。另外，它也描述了和JavaSE第7版一同发布的《Java虚拟机规范JavaSE第7版》里的一些内容，主要的改变可以总结如下：</p><ul><li>从JavaSE第5版引入泛型，支持可变参数的方法</li><li>从JavaSE第6版后字节码验证过程发生了改变</li><li>添加了invokedynamic指令和为了支持动态类型语言的相关类文件格式</li><li>删除了Java语言本身概念的描述，让读者到Java语言规范去查看这部分内容。</li><li>删除了有关Java线程和锁的描述，将这些内容放在了Java语言规范中。</li></ul><p>这些当中最大的改变就是invokedynamic指令的添加。这意味着JVM内部的指令集发生了改变，JVM开始支持类型可以不确定的动态类型语言，就像一个脚本语言一样，也是JavaSE第7版后的Java语言。之前未被使用的编号186的操作码被分配给了新的指令：invokedynamic，为了支持invokedynamic新的内容也被添加到了类文件格式中。<br>由JavaSE第7版的Java编译器产生的类文件的版本是51.0，JavaSE第6版是50.0。类文件格式中的许多内容被改变了，因此51.0版本的类文件不能在JavaSE第6版的JVM上执行。</p><p>除去这些各式各样的改变，65536字节的Java方法大小的限制依然没有被移除。除非JVM类文件格式有创新式的改变，否则在未来也不会被移除。</p><p>以备参考，Oracle的Java第7版虚拟机支持G1这种新的垃圾收集器。但是仅限于Oracle的虚拟机，所以JVM本身不会限制垃圾收集器的类型。因此JVM规范就没有描述这些内容了。</p><h2 id="switch语法中的String类型"><a href="#switch语法中的String类型" class="headerlink" title="switch语法中的String类型"></a>switch语法中的String类型</h2><p>JavaSE第7版添加了各种新的语法与特性，但是与JavaSE第7版语言诸多的改变相比，JVM却没有太大的改变。所以，JavaSE第7版的新特性要如何被实现？我们将通过反编译来看看switch语句中的String类型是如何实现支持的。（一个向switch语句添加一个字符串来作对比的功能）<br>例如，有以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SwitchTest</span><br><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public int doSwitch(String str) &#123;</span><br><span class="line">        switch (str) &#123;</span><br><span class="line">        case &quot;abc&quot;:        return 1;</span><br><span class="line">        case &quot;123&quot;:        return 2;</span><br><span class="line">        default:         return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然这是JavaSE第7版的新功能，它就可以被JavaSE第6版或是更低版本的编译器编译。使用JavaSE第7版的javac命令编译，以下就是javap -c反编译的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">C:Test&gt;javap -c SwitchTest.classCompiled from &quot;SwitchTest.java&quot;</span><br><span class="line">public class SwitchTest &#123;</span><br><span class="line">  public SwitchTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return  public int doSwitch(java.lang.String);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_1</span><br><span class="line">       1: astore_2</span><br><span class="line">       2: iconst_m1</span><br><span class="line">       3: istore_3</span><br><span class="line">       4: aload_2</span><br><span class="line">       5: invokevirtual #2                  // Method java/lang/String.hashCode:()I</span><br><span class="line">       8: lookupswitch  &#123; // 2</span><br><span class="line">                 48690: 50</span><br><span class="line">                 96354: 36</span><br><span class="line">               default: 61</span><br><span class="line">          &#125;</span><br><span class="line">      36: aload_2</span><br><span class="line">      37: ldc           #3                  // String abc</span><br><span class="line">      39: invokevirtual #4                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      42: ifeq          61</span><br><span class="line">      45: iconst_0</span><br><span class="line">      46: istore_3</span><br><span class="line">      47: goto          61</span><br><span class="line">      50: aload_2</span><br><span class="line">      51: ldc           #5                  // String 123</span><br><span class="line">      53: invokevirtual #4                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      56: ifeq          61</span><br><span class="line">      59: iconst_1</span><br><span class="line">      60: istore_3</span><br><span class="line">      61: iload_3</span><br><span class="line">      62: lookupswitch  &#123; // 2</span><br><span class="line">                     0: 88</span><br><span class="line">                     1: 90</span><br><span class="line">               default: 92</span><br><span class="line">          &#125;</span><br><span class="line">      88: iconst_1</span><br><span class="line">      89: ireturn</span><br><span class="line">      90: iconst_2</span><br><span class="line">      91: ireturn</span><br><span class="line">      92: iconst_0</span><br><span class="line">      93: ireturn</span><br></pre></td></tr></table></figure><p>一个明显比Java源码更长的字节码产生了。首先，你可以在Java字节码中看到switch语句使用了一个lookupswitch指令。但是，有2个lookupswitch指令被使用了，而不是一个。当反编译switch语句中的加了int的case时，只会调用一条lookupswitch指令，这意味着switch()语句被分成两个语句块去处理String。观察#5，#39和#53处的字节码指令来了解switch()是如何处理String的。<br>在#5和#8处的字节码首先调用了hashCode()方法，它的结果被switch(int)使用了。在lookupswitch指令的大括号中，根据hashCode结果值的不同创建了不同位置的分支。字符串“abc”的hashCode结果值为96354，被移到了#36字节码处。字符串“123”的hashCode结果值是48690，被移到了#50字节码处。</p><p>在#36，#37，#39和#42字节码处，你可以看到str变量值被当作参数接收并使用字符串“abc”和equals()方法与之比较。如果结果相同，‘0’将被插入本地变量数组#3索引处，string被移到#61字节码处。</p><p>这样，在#50，#51，#53和#56处的字节码，你可以看到str变量值被当作参数接收并使用字符串“123”和equals()方法与之比较。如果结果相同，‘1’将被插入本地变量数组#3索引处，string被移到#61字节码处。</p><p>在#61和#62字节码处，本地变量数组#3索引处的值，也就是‘0’，‘1’，或其它的任何值，将被lookupswitch使用并创建分支。</p><p>换句话说，在Java代码中，str变量值被当作参数接收并使用hashCode和equals()方法与之比较。有了int结果值后，执行switch()语句。</p><p>在这个案例中，编译后的字节码与之前JVM的规范没有什么不同。JavaSE第7版的新特性switch支持String由Java编译器处理，而不是JVM本身。这样的话，JavaSE第7版的其它新特性也由Java编译器处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我不认为我们需要回顾Java是如何发展的来更好的使用Java。许多的开发者没有深刻地理解JVM也开发出了很好地应用和库。但是，如果你更多地去理解JVM，这将更有助于你去解决像以上例子中的问题。<br>除了这里提到的描述，JVM还有许多的特性和技术。JVM规范提供了一个灵活的规范让JVM供应商来提供更高级的特性，许多不同的技术可以被供应商使用。尤其是垃圾收集器技术被大部分提供与VM相同的功能的语言使用，是最新的最有技术的性能。但是，因为在许多的杰出研究中已经讨论这个问题，我就不在这篇文章中详细解释这一点了。</p><p>如果你是韩文使用者并且需要JVM内部结构的更多信息，我建议你去阅读《Java基本性能》(Hando Kim, Seoul, EXEM, 2009)。我像参考JVM规范一样也参考了这部书来写这篇文章。如果你是英文使用者，那应该有很多涉及Java性能主题的书可以查阅。</p><p>last update:2018-7-16</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看到一篇说JVM的外文写的不错，自己翻译一下。</summary>
    
    
    
    
    <category term="JVM" scheme="https://kevll.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分治与递归的分析</title>
    <link href="https://kevll.com/2018/03/07/%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://kevll.com/2018/03/07/%E5%88%86%E6%B2%BB%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.164Z</updated>
    
    <content type="html"><![CDATA[<p>此篇基于我在分析快速排序的时间复杂度时遇到的问题，我没能较好地理解它的运算模式。分治与递归是这个算法重要的两个部分，也比较难弄透，这篇详细分解下。<span id="more"></span></p><p>分治法将一个复杂的问题拆分成多个易解的小问题，最后将所有的解合并起来得到最终的答案。因为在拆分的过程中会出现逐层嵌套和分解的情况，所以这时候递归显得十分的适用。分治和递归像是一对好伙伴，经常在一起工作，因此也产生了许多高效的算法。快速排序就是很经典的一个运用，可是虽然了解实现原理，写起来也不是很熟练，因为里面包含一些边界问题和结束条件比较难把握。</p><p>了解算法运行过程最有效的方法就是分解其运行过程，下面分解下快速排序{6,10,12,14,3,5,23}的过程。</p><p>数组本身是无序的，我在这默认每次取当前排序组合中的第一位作为基准数，那么第一次排的数就是6，函数执行一遍后会将比6小的数都排在6之前，比6大的排在6之后。i，j分别表示当前组合的第一个索引位和最后一个索引位。这里有个边界问题，就是如果和基准数一样大的数该如何排列。其实一样大的数放在左边和右边都可以，最后的排序结果就是一样大的连在一起，选择一种即可。这里我写的是大于等于放在右边，小于放在左边。还有一个边界就是在步进后如果重合了，就不执行操作了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while (i &lt; j) &#123;</span><br><span class="line">while (i &lt; j &amp;&amp; array[j] &gt;= x)//边界：小于x才满足放在左边的条件，所以j&gt;=x的时候是去找下一个数</span><br><span class="line">j--;</span><br><span class="line">if (i &lt; j)//边界：i，j重合，不执行操作</span><br><span class="line">array[i++] = array[j];</span><br><span class="line"></span><br><span class="line">while (i &lt; j &amp;&amp; array[i] &lt; x)</span><br><span class="line">i++;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">array[j--] = array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>()表示i的索引位置，[]表示j的索引位置。<br>排序开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始：6为基准数</span><br><span class="line">(6),10,12,14,3,5,[23]</span><br><span class="line"></span><br><span class="line">1: j-</span><br><span class="line">(5),10,12,14,3,[5],23</span><br><span class="line"></span><br><span class="line">2: i+</span><br><span class="line">5,(10),12,14,3,[10],23</span><br><span class="line"></span><br><span class="line">3: j-</span><br><span class="line">5,(3),12,14,[3],10,23</span><br><span class="line"></span><br><span class="line">4: i+</span><br><span class="line">5,3,(12),14,[12],10,23</span><br><span class="line"></span><br><span class="line">5: j- 与i重合</span><br><span class="line">5,3,[(12)],14,12,10,23</span><br><span class="line"></span><br><span class="line">将基准数填入重合索引位:</span><br><span class="line">5,3,6,14,12,10,23</span><br></pre></td></tr></table></figure><p>此时以6为基准数的第一遍排序已经完成，这时候原来的7位数的排序问题就被分成了2个小数组排序的问题。这里也有一个边界问题，就是6的所在位置就是它的最终位置，所以剩下的两个无序数组为：5，3和14，12，10，23。开始递归剩下来的数组时，就可以把6的位置排除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//递归调用</span><br><span class="line">quick_sort(array, left, i - 1);//i为重合处索引</span><br><span class="line">quick_sort(array, i + 1, right);</span><br></pre></td></tr></table></figure><p>第一行递归：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">初始：5为基准数</span><br><span class="line">(5),[3]</span><br><span class="line"></span><br><span class="line">1: j未减已满足比5小</span><br><span class="line">(3),[3]</span><br><span class="line"></span><br><span class="line">2：i++</span><br><span class="line">3,([3])</span><br><span class="line"></span><br><span class="line">将基准数填入重合索引位:</span><br><span class="line">3,5</span><br></pre></td></tr></table></figure><p>此时left&#x3D;0，i&#x3D;1，即调用quick_sort(array, left, i - 1)-&gt;quick_sort(array,0,0);到达了函数的终止条件。这个终止条件并没有显示的写出，可以再看下函数的限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (left &lt; right) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，当left和right相同时，不满足函数的继续执行条件，而对递归的调用也在方法块中，自然也不会执行。这个递归就到此结束了。这时候第一行递归已经全部完成，执行第二行递归。这里用的数组较小，如果没排完将一直循环递归下去，直到当前组合全部排序完毕。此时3，5，6的最终位置都已完成，最后将6右边比6大的数组按照以上同样的方式递归完后，整个数组排序就完成了。</p><p>last-updated: 2018-03-15</p><p>参考：<br><a href="http://blog.csdn.net/morewindows/article/details/6684558">MoreWindows 白话经典算法系列之六</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇基于我在分析快速排序的时间复杂度时遇到的问题，我没能较好地理解它的运算模式。分治与递归是这个算法重要的两个部分，也比较难弄透，这篇详细分解下。</summary>
    
    
    
    
    <category term="算法" scheme="https://kevll.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序的Onlogn是如何计算的</title>
    <link href="https://kevll.com/2018/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84Onlogn%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84/"/>
    <id>https://kevll.com/2018/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84Onlogn%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84/</id>
    <published>2018-02-18T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.164Z</updated>
    
    <content type="html"><![CDATA[<p>在学习算法的过程当中，涉及到了算法的效率问题，这里有一个时间复杂度可以用来衡量算法在时间上的消耗，当时看冒泡排序的时间复杂度很好理解，但是快速排序的nlogn就弄不明白了，决定研究一下。<span id="more"></span></p><p>这里回顾下冒泡的时间复杂度计算过程，比较简单，我们一般在写冒泡排序的代码时，就是套上了2层循环，其中对n的值进行变化。冒泡排序实际是拿每一个元素和后面的元素进行依次比较，所以每轮比较后将会把当前未排序的数字中最大或最小的值排到最后，故每次比较的次数都会减一，也就是第二层循环会递减，排完n-1次后，第一个数不需要再排列，其时间复杂度的计算过程如下：</p><p>(n-1)+(n-2)+(n-3)+…+1+0 一共n个数的比较过程<br>(n-1)*(n-1+1)&#x2F;2&#x3D;(n^2-n)&#x2F;2<br>舍弃低次幂得到O&#x3D;n^2</p><p>快速排序用的是分治法加递归，这里贴上java的实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void quick_sort(int array[], int left, int right) &#123;</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">int i = left; </span><br><span class="line">int j = right;</span><br><span class="line">int x = array[left];//选取第一个数为基准数</span><br><span class="line"></span><br><span class="line">while (i &lt; j) &#123;</span><br><span class="line">while (i &lt; j &amp;&amp; array[j] &gt;= x)</span><br><span class="line">j--;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">array[i++] = array[j];</span><br><span class="line"></span><br><span class="line">while (i &lt; j &amp;&amp; array[i] &lt; x)</span><br><span class="line">i++;</span><br><span class="line">if (i &lt; j)</span><br><span class="line">array[j--] = array[i];</span><br><span class="line">&#125;</span><br><span class="line">array[i] = x;</span><br><span class="line"></span><br><span class="line">//递归调用</span><br><span class="line">quick_sort(array, left, i - 1);</span><br><span class="line">quick_sort(array, i + 1, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个叫主定理的东西：T [n] &#x3D; aT[n&#x2F;b] + f (n)<br>其中 a &gt;&#x3D; 1 and b &gt; 1 是常量 并且 f (n) 是一个渐近正函数，为了使用这个主定理，需要考虑下列三种情况：<br><img src="/180529_master_method.jpg" alt="主定理的三种情况(图片来源网络)"></p><p>快排每次把一个问题分成两个子问题，则有：<br>T[n]&#x3D;2T[n&#x2F;2]+O(n), O(n)为partition()的时间复杂度。<br>对比主定理，此时的a&#x3D;2, b&#x3D;2, f(n)&#x3D;O(n)<br>那么：n<sup>log<sub>b</sub>a</sup>&#x3D;n, 属于case2，所以快排的时间复杂度为O(nlogn)</p><p>说实话，我还是有点迷糊，这里只有一个公式，并不知道公式是怎么来的，而且还有其它的计算方法。后来还了解到涉及到分治和递归的算法的时间复杂度都会有log，这块还要抽空回过头来研究一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在学习算法的过程当中，涉及到了算法的效率问题，这里有一个时间复杂度可以用来衡量算法在时间上的消耗，当时看冒泡排序的时间复杂度很好理解，但是快速排序的nlogn就弄不明白了，决定研究一下。</summary>
    
    
    
    
    <category term="算法" scheme="https://kevll.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HashMap</title>
    <link href="https://kevll.com/2018/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
    <id>https://kevll.com/2018/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2022-01-18T10:26:49.167Z</updated>
    
    <content type="html"><![CDATA[<p>之前浅显地了解过HashMap是由数组加上链表实现的，但是一直没有真正理解到他的结构到底是怎样的，现在记录下自己学习HashMap的过程和理解，本篇研究了put与resize的源码实现、HashMap的关于桶大小及扩展的一些细节、以及jdk1.8做了哪些优化。<span id="more"></span><!-- more --></p><h2 id="数组与链表的结合"><a href="#数组与链表的结合" class="headerlink" title="数组与链表的结合"></a>数组与链表的结合</h2><p>在之前的学习中，了解到数组在内存中是一组连续的存储。它便于遍历和查询，但是不方便插入和删除。例如在一个存储了100个元素的ArrayList中，在索引为50的位置插入一个元素，则从索引为50开始往后的所有元素都需要后移，这无疑是非常大的消耗。但数组的查找时间复杂度小，为O(1)。而链表是一种离散的存储，插入和删除只需要修改链接的指向，但搜索的时间复杂度达到O(n)。<br>所以在HashMap中结合了两者的特性，让HashMap成为了一种寻址容易，插删也容易的数据结构。在这里用到的就是哈希表，哈希表为了解决冲突，主要有两种实现方法：开放地址法和链地址法。在HashMap中使用的是链地址法，也可称为拉链法，可理解为“链表的数组”。</p><p>HashMap中，有一个重要的Node[] table，Node实现了Map的静态内部类Entry，其中重要的属性有key，value，next，保存的就是键值对和到下一个Node的引用。</p><h2 id="put与get的基本操作"><a href="#put与get的基本操作" class="headerlink" title="put与get的基本操作"></a>put与get的基本操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//存储</span><br><span class="line">int hash=key.hashCode();</span><br><span class="line">int index=hash&amp;(Entry[].length-1);</span><br><span class="line">Entry[index]=value;</span><br><span class="line">//取值</span><br><span class="line">int hash=key.hashCode();</span><br><span class="line">int index=hash&amp;(Entry[].length-1);</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure><p>这样，就基本将键值对均匀的分布在了数组中。<br>如果两个key经过hash后得到的index相同，会发生什么？例如Entry[0]&#x3D;A之后，又来了一个元素B，其经过运算后的index也是0。这时就要用到链表的结构了，前面说道Entry有一个为next的属性，所以此时B.next&#x3D;A，Entry[0]&#x3D;B。Entry[0]处将一直存储着最后插入的元素。</p><h2 id="代码详细剖析"><a href="#代码详细剖析" class="headerlink" title="代码详细剖析"></a>代码详细剖析</h2><p>jdk1.8，put-&gt;putVal</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;    //HashMap的元素数组</span><br><span class="line">    Node&lt;K,V&gt; p;        //数组中准备插入的索引位置的原始Node</span><br><span class="line">   </span><br><span class="line">    int n, i;           //n：元素数组的长度，i：准备插入的经过hash运算过后的索引值</span><br><span class="line">    </span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0) //如果元素数组为null或长度为0，则resize</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)          //如果原索引处为空，新建一个Node</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;    //原始key</span><br><span class="line">        </span><br><span class="line">        //如果索引处有原始Node，且key值相同，赋给e</span><br><span class="line">        if (p.hash == hash &amp;&amp;   </span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) </span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        //如果为TreeNode，直接插入红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        //遍历链表准备插入</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                //如果Node的next为空，插入next</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //如果链表的长度超过了阈值（默认为8），转为红黑树处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果插入元素与next的key值相同，直接覆盖</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                //链表后移一位</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ++modCount;  //表结构修改次数增加</span><br><span class="line">   </span><br><span class="line">    if (++size &gt; threshold)  //如果增加后的元素数目超过了阈值，则resize</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.8的扩容代码好像有点复杂，包含红黑树，先分析一下jdk1.7的resize</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;         </span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //如果元素超过了最大容量1&lt;&lt;20(2^30) 1048576</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transfer()将原有Entry数组的元素拷贝至新的容量更大的数组。拷贝后旧数组同一条Entry链上的元素可能将被放到不同位置上，因为元素的索引都经过了重新计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">   int newCapacity = newTable.length;</span><br><span class="line">   for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">      if (e != null) &#123;</span><br><span class="line">        src[j] = null;//释放原数组索引位置对象，等待回收</span><br><span class="line">        do &#123;</span><br><span class="line">           Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">           int i = indexFor(e.hash, newCapacity); //重新计算索引</span><br><span class="line">           e.next = newTable[i]; //头插入，新元素.next指向原第一位元素(第一次指向null)</span><br><span class="line">           newTable[i] = e;      //将最新的元素放在数组第一位</span><br><span class="line">           e = next;             //遍历后移</span><br><span class="line">           &#125; while (e != null);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容量与负载因子"><a href="#容量与负载因子" class="headerlink" title="容量与负载因子"></a>容量与负载因子</h2><p>在HashMap中，有两个重要的值，它们是桶容量和负载因子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure><p>默认的初始容量是16、负载因子是0.75。HashMap当前能存放的最大数据量threshold&#x3D;(容量*负载因子)，超过这个数据量就要进行扩容，扩容后是之前容量的2倍。默认的0.75负载因子是一个对时间和空间的均衡，一般的情况下都不需要修改，如果场景比较特殊，比如内存很多而对时间效率要求高就可以降低负载因子的值；而如果内存紧张对时间效率要求也不高的话就可以增加负载因子的值，这个值可以超过1。</p><h2 id="2次方桶的作用"><a href="#2次方桶的作用" class="headerlink" title="2次方桶的作用"></a>2次方桶的作用</h2><p>在HashMap中，哈希桶的大小必须是2的N次方（一定是合数）。一般情况下，素数导致冲突的概率要小于合数，HashTable初始化桶的大小为11就是素数的应用。HashMap这样设计是为了在hash取模和扩容的时候做优化。接下来看下HashMap的hash算法和扩容机制，下面是hash算法与优化的取模运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//HashMap在put值的时候，将先执行一遍hash算法，计算hash</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">//hash算法</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//取模，1.8没有这个方法，取模运算放在了具体调用的地方</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在平均一批元素的时候，我们常常的操作就是直接对容器的容量大小进行取模运算，这样元素的分布式相对比较均匀的。但是在计算机中模运算的消耗是比较大的，当桶的大小是2的n次方时，总有h%length &#x3D; h&amp;(length-1)。这个取模运算的效率是非常重要的，因为在put和get时，对元素的索引进行计算的时候都要经过这个方法，而&amp;比%有更高的效率。</p><p>hash算法越分散均匀，hash碰撞的概率就越小，map的存取效率就越高。</p><p>1.8之后，使用的是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。所以，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/21673805">美团点评技术团队：Java8系列之重新认识HashMap</a><br><a href="https://monkeysayhi.github.io/2017/08/26/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">猴子007：HashMap实现原理</a><br><a href="https://www.cnblogs.com/softidea/p/7261111.html">沧海一滴：深入理解HashMap</a><br>jdk1.7, jdk1.8 源码</p><p>last update: 2018-06-27</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前浅显地了解过HashMap是由数组加上链表实现的，但是一直没有真正理解到他的结构到底是怎样的，现在记录下自己学习HashMap的过程和理解，本篇研究了put与resize的源码实现、HashMap的关于桶大小及扩展的一些细节、以及jdk1.8做了哪些优化。</summary>
    
    
    
    
    <category term="源码" scheme="https://kevll.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="https://kevll.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
