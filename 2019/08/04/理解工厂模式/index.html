<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 理解工厂模式 · kev's blog</title><meta name="description" content="理解工厂模式 - kevin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://kevll.com/atom.xml" title="kev's blog"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="kev's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/kitscode" target="_blank">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">理解工厂模式</h1><div class="post-info">2019年8月4日</div><div class="post-content"><p>工厂设计模式是众多设计模式当中我最早接触的设计模式，也是一种应用最为广泛的设计模式，属于创建型设计模式。在Spring框架中，也有很经典的应用。在我对其进行了解的时候，发现有几种不同的工厂模式，本文对这几种工厂模式之间的差别进行一下分析和解读。<span id="more"></span></p>
<p>工厂模式的产生，是为了降低代码耦合，统一管理产品，提高工作效率。</p>
<h3 id="四种常见的工厂模式"><a href="#四种常见的工厂模式" class="headerlink" title="四种常见的工厂模式"></a>四种常见的工厂模式</h3><ol>
<li>StaticFactory Method - 静态工厂方法</li>
<li>SimpleFactory - 简单工厂</li>
<li>Factory Method - 工厂方法</li>
<li>Abstract Factory - 抽象工厂模式</li>
</ol>
<h4 id="StaticFactory-Method"><a href="#StaticFactory-Method" class="headerlink" title="StaticFactory Method"></a>StaticFactory Method</h4><p>相对于构造器来说，静态工厂有如下优势：</p>
<ul>
<li>方法名称不是固定的，可以自定义有意义的方法名称</li>
<li>返回值可以是原类型、子类型或是原始类型</li>
<li>可以控制类的实例，单例模式就是一种很好的应用</li>
</ul>
<p>静态工厂在jdk中也有使用，例如String、Integer、Long、Optional、Collections等包含的一系列静态工厂方法：</p>
<ul>
<li>String.valueOf(1000L);</li>
<li>Integer.valueOf(“180”);</li>
<li>Long.valueOf(“9999”);</li>
<li>Optional.of(“value”);</li>
<li>Collections.synchronizedCollection(originalCollection);</li>
</ul>
<h4 id="Simple-Factory"><a href="#Simple-Factory" class="headerlink" title="Simple Factory"></a>Simple Factory</h4><p>简单工厂模式，有一个专门的工厂类，可以根据参数去生产特定的产品，它不属于23GOF。例如下面的一个电脑工厂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static final int HP = 1;</span><br><span class="line">    public static final int LENOVO = 2;</span><br><span class="line">    public static final int APPLE = 3;</span><br><span class="line"></span><br><span class="line">    public static Computer createComputer(int param) &#123;</span><br><span class="line">        switch (param) &#123;</span><br><span class="line">            case HP:</span><br><span class="line">                return new HpComputer();</span><br><span class="line">            case LENOVO:</span><br><span class="line">                return new LenovoComputer();</span><br><span class="line">            case APPLE:</span><br><span class="line">                return new AppleComputer();</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h4><p>工厂模式有一个工厂父类，提供了生产电脑的接口，各个厂牌的工厂可以去继承并实现它，完成自己的生产逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 父类工厂</span><br><span class="line">public interface ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    Computer createComputer();</span><br><span class="line">&#125;</span><br><span class="line">// 惠普工厂实现</span><br><span class="line">public class HpComputerFactory implements ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Computer createComputer() &#123;</span><br><span class="line">        return new HpComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 联想工厂实现</span><br><span class="line">public class LenovoComputerFactory implements ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Computer createComputer() &#123;</span><br><span class="line">        return new LenovoComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h4><p>到了抽象工厂，就要提到产品簇（Product Family）的概念。产品簇指的是具有相似功能的一系列产品，它们通常需要聚合或是搭配着来完成一项功能。例如上面的电脑产品，其可以被拆分为主机、屏幕、键盘、鼠标、耳机等等。这些拆分的部件通常也不是在一个工厂完成生产，而且也不一定都和自己的厂牌结合使用。厂牌下的各个子产品的生产逻辑抽象出来产生了抽象工厂这种设计方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 父类产品工厂</span><br><span class="line">public interface ComputerProductFactory &#123;</span><br><span class="line"></span><br><span class="line">    Keyboard createKeyboard();</span><br><span class="line"></span><br><span class="line">    Mouse createMouse();</span><br><span class="line"></span><br><span class="line">    Earphone createEarphone();</span><br><span class="line">&#125;</span><br><span class="line">// 惠普产品工厂实现</span><br><span class="line">public class HpProductFactory implements ComputerProductFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Keyboard createKeyboard() &#123;</span><br><span class="line">        return new HpKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mouse createMouse() &#123;</span><br><span class="line">        return new HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Earphone createEarphone() &#123;</span><br><span class="line">        return new HpEarphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 联想产品工厂实现</span><br><span class="line">public class LenovoProductFactory implements ComputerProductFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Keyboard createKeyboard() &#123;</span><br><span class="line">        return new LenovoKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mouse createMouse() &#123;</span><br><span class="line">        return new LenovoMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Earphone createEarphone() &#123;</span><br><span class="line">        return new LenovoEarphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>产品簇指具有相同或相似的功能结构或性能，共享主要的产品特征、组件或子结构，并通过变型配置来满足特定市场的一组产品的聚类。其背景是一个规划精良的结构，即可以用来生成产品族的产品族概念结构和总体逻辑结构，有助于把握和利用产品的共性。每一个新产品都是该结构的具体实例，也是对结构的扩展。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2019/09/16/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">PREV</a><a class="next" href="/2019/04/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%88%AB/">NEXT</a></div><div class="copyright"><p>© 2018 - 2022 <a href="https://kevll.com">kevin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>